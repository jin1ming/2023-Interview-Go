## 支付系统设计 (面试重点)

在购买与支付核心模块的设计中，为了保证交易的**数据一致性**和**高可靠性**，系统采用了**订单与支付分离**的架构模式，并结合**状态机**来管理复杂的交易流转。

### 1. 数据库设计
交易意图（Order）和支付动作（Payment）解耦，设计了 **1:N** 的关系，支持用户多次尝试支付。

#### 订单表 (`order`)
记录“谁买了什么”，核心字段：
*   `id`: 分布式雪花算法生成，全局唯一。
*   `amount`: 实付金额（分），避免浮点数精度问题。
*   `status`: 核心状态机字段（待支付、已支付、已取消等）。
*   `payment_id`: 指向**当前**最新的一次支付尝试，用于快速索引。
*   `created_at`: 用于超时关单（Daemon 扫描）。

#### 支付流水表 (`payment`)
记录与第三方支付渠道的交互流水：
*   `id`: 传给微信/支付宝的 `OutTradeNo`。
*   `order_id`: 逻辑外键，关联 Order 表。
*   `trade_id`: 渠道交易号（TransactionId），用于对账和退款。
*   `status`: Processing (支付中), Success (成功), Failed (失败)。

### 2. 核心状态流转 (Status Lifecycle)

#### 正常流程
1.  **`InProgress`**: 下单成功，事务提交，生成 `Payment` (Processing)。
2.  **`Success`**: 收到回调（或主动查询确认），原子化执行：更新 `Payment` -> 更新 `Order` -> **触发履约（生成门票/出库）**。

#### 异常/逆向流程
1.  **`Invalid`**: 后台 Daemon 扫描超时未支付订单 -> 标记失效 -> **回滚优惠券** -> 释放库存。
2.  **`Canceled`**: 用户主动取消 -> 调用微信关单接口 -> 标记已取消。
3.  **`Refunded`**: 客服发起退款 -> 调用微信退款接口 -> 标记已退款 -> 回滚权益。

### 3. 面试常见问题应对

#### Q: 如何保证“下单”的一致性？
**A**: 在 `Create` 接口中使用数据库事务（Transaction）：锁库存/校验 -> 核销优惠券 -> 写入订单。确保“扣券”和“生成订单”原子化，避免悬挂状态。

#### Q: 支付回调的“幂等性”怎么做？
**A**: 利用数据库状态作为乐观锁。在 `PaySuccess` 中检查：若订单状态已是 `Success`，直接返回，防止重复发货；若为 `InProgress`，才执行更新和出票逻辑。

#### Q: 为什么会有“超时关单”？
**A**: 防止恶意占用库存资源。通过后台 Daemon 协程定期扫描超时订单进行“软删除”，释放占用的资源。

### 4. 系统优化方向 (加分项)
*   **抗高并发**: 引入 Redis 实现库存/优惠券的“预扣减”，异步落库，解决 DB 行锁瓶颈。
*   **时效性**: 使用**延迟队列** (Delay Queue) 替代轮询 DB，精准触发关单，减少无效扫描。
*   **数据安全**: 在回调入口增加 **Redis 分布式锁**，防止极端并发下的重复出票；引入 **T+1 对账系统**，保障资金安全。

---

## 七、 总结

Carina 展示了一个 **高可用、数据强一致** 的票务系统后端设计。其最突出的优点在于：
1.  **安全性**: 通过严格的事务和悲观锁保证了资产（票、钱、券）的安全。
2.  **可维护性**: 通过 Supplier 模式和集中式状态机管理，使得代码结构清晰，易于扩展。
3.  **健壮性**: 守护线程的设计保证了异常情况下的数据自愈能力。
