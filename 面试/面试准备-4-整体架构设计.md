# 云边协同系统 - 整体架构设计

## 一、系统全景图

```
┌──────────────────────────────────────────────────────────────────────────┐
│                           互联网 / 云端                                   │
├──────────────────────────────────────────────────────────────────────────┤
│  Star（云端SaaS平台）                                                    │
│  ├─ 前端：Vue2 + TypeScript + Element UI                                 │
│  ├─ 网关：Kong（路由、认证、限流）                                       │
│  ├─ 认证：Keycloak（飞书、微信登录）                                     │
│  ├─ 后端服务：                                                           │
│  │  ├─ 租户管理（Node.js）                                              │
│  │  ├─ 结算系统（Node.js）                                              │
│  │  ├─ 设备管理（Golang）                                               │
│  │  └─ 视频检索（Golang）                                               │
│  ├─ 数据存储：                                                           │
│  │  ├─ PostgreSQL（业务数据）                                            │
│  │  ├─ Redis（缓存、分布式锁）                                           │
│  │  ├─ ClickHouse（大数据分析）                                          │
│  │  └─ S3/MinIO（对象存储）                                              │
│  ├─ 中间件：                                                             │
│  │  ├─ Kafka（消息队列）                                                │
│  │  ├─ ThingsBoard（IoT平台）                                            │
│  │  ├─ K3s（容器编排）                                                  │
│  │  └─ Prometheus + Grafana（监控）                                      │
└──────────────────────────────────────────────────────────────────────────┘
                    ◄─── MQTT / HTTP ───►
                    │
    ┌───────────────┼───────────────┐
    │               │               │
    ▼               ▼               ▼
┌─────────┐   ┌─────────┐   ┌─────────┐
│ Dipper  │   │ Dipper  │   │ Dipper  │
│ 社区1   │   │ 社区2   │   │ 社区3   │
└─────────┘   └─────────┘   └─────────┘
    │               │               │
    ├─ Merak（任务调度）
    ├─ Alioth（视频下载）
    ├─ Mizar（视频处理）
    └─ Dubhe（系统管理）
    │
    ├─ 摄像头群组1
    ├─ 摄像头群组2
    └─ 摄像头群组3
```

---

## 二、分层架构

### 2.1 表现层 - 前端应用

**Vue2 + TypeScript + Element UI**
- 租户管理：创建、编辑、删除、权限管理
- 设备管理：设备列表、配置、监控、告警
- 视频检索：人脸检索、行为分析、轨迹追踪
- 结算管理：账单查看、费用统计、欠费预警

### 2.2 接入层 - API网关

**Kong API Gateway**
- 路由转发：请求分发到不同服务
- 认证授权：JWT验证、权限检查
- 限流熔断：防止服务过载
- 租户隔离：请求头注入tenantId，跨租户检查

**Keycloak身份认证**
- 用户名密码认证
- 飞书/微信OAuth
- 角色权限管理
- Token生成和刷新

### 2.3 业务逻辑层 - 微服务

**租户管理服务（Node.js）**
- 租户生命周期：创建、启用、禁用、删除
- 数据隔离：数据库、缓存、存储、网关四层隔离
- 配置管理：S3、Kafka、功能开关、计费规则
- 区域管理：组织架构、权限继承、资源分配

**结算系统（Node.js）**
- 计费规则：按设备、流量、时间计费
- 账单生成：日结、月结、发票生成
- 欠费管理：预警、自动停用、恢复流程
- 报表统计：收入、用户、设备统计

**设备管理服务（Golang）**
- 设备注册：认证、激活、分组
- 配置下发：参数、固件、策略
- 状态监控：在线状态、健康度、性能指标
- 远程控制：重启、恢复、诊断

### 2.4 数据访问层 - 存储

**PostgreSQL - 业务数据**
```
核心表：
├─ tenants（租户）
├─ areas（区域）
├─ devices（设备）
├─ users（用户）
├─ billing（账单）
└─ audit_logs（审计日志）

索引：(tenant_id, created_at)
隔离：所有表都有tenant_id字段
```

**Redis - 缓存 & 分布式锁**
```
Key设计：
├─ tenant:{tenantId}:{key}
├─ device:{deviceId}:status
├─ lock:{resource}
└─ session:{sessionId}

Pub/Sub：
├─ tenant:cache:invalidate
├─ device:status:changed
└─ config:updated
```

**ClickHouse - 大数据分析**
```
核心表：
├─ events（事件）
├─ snapshots（抓拍记录）
└─ metrics（性能指标）

分区：按天/按小时
优化：预聚合、物化视图
```

**S3/MinIO - 对象存储**
```
目录：{tenantId}/videos/{deviceId}/{date}/
隔离：租户级别隔离
访问：临时签名URL
```

### 2.5 基础设施层

**Kafka - 消息队列**
- tenant.created、tenant.updated
- device.registered、device.status.changed
- config.updated、billing.generated
- alert.triggered

**ThingsBoard - IoT平台**
- 设备管理、认证、双向通信
- RPC远程调用、属性同步
- 状态监控、离线队列

**K3s - 容器编排**
- Pod部署、服务发现
- 负载均衡、自动扩展
- 存储管理、配置管理

**Prometheus + Grafana - 监控**
- 应用指标：延迟、错误率、吞吐量
- 系统指标：CPU、内存、磁盘、网络
- 告警规则：错误率、响应时间、资源占用

---

## 三、核心业务流程

### 3.1 租户开通流程

```
1. 运营人员在Star前端创建租户
2. Kong网关 → 租户管理服务
3. 开启数据库事务
   ├─ 创建租户记录（PostgreSQL）
   ├─ 创建Keycloak用户
   ├─ 创建ThingsBoard Customer
   ├─ 创建人脸特征库
   └─ 提交事务
4. 发送Kafka事件：tenant.created
5. 缓存更新服务订阅事件
   ├─ 更新Redis缓存
   └─ 广播Pub/Sub
6. 返回成功响应
7. 管理员登录 → 配置设备
```

### 3.2 视频检索流程

```
1. 用户在Star前端发起检索
   ├─ 输入：人员特征、时间范围、设备范围
   └─ Kong网关 → 视频检索服务

2. 查询人员特征向量（PostgreSQL）

3. 通过ThingsBoard下发任务到Dipper
   ├─ RPC调用：CreateTask
   ├─ 参数：特征向量、时间范围、设备
   └─ 返回：taskId

4. Dipper边缘端接收任务
   ├─ Merak快速响应（100ms）
   ├─ 异步执行任务
   └─ 通知ThingsBoard：task accepted

5. 后台执行任务
   ├─ 分页加载视频元信息
   ├─ 调用Alioth下载视频
   ├─ 调用Mizar提取关键帧
   ├─ AI推理：人脸识别
   ├─ 相似度计算
   ├─ 保存匹配结果
   └─ 实时上报进度

6. 结果上报到Star
   ├─ 发送Kafka事件
   ├─ 更新ClickHouse
   └─ 更新Redis缓存

7. 用户查看结果
   ├─ 从ClickHouse查询结果
   ├─ 生成临时签名URL
   └─ 返回结果列表
```

### 3.3 月底结算流程

```
1. 定时任务（每月1号凌晨）启动结算服务

2. 统计上月数据
   ├─ 按租户统计设备使用天数
   ├─ 按租户统计流量消耗
   ├─ 按租户统计API调用次数
   └─ 从PostgreSQL和ClickHouse查询

3. 计算费用
   ├─ 读取租户计费规则（Redis缓存）
   ├─ 应用优惠规则
   ├─ 计算应付金额
   └─ 生成账单

4. 保存账单
   ├─ 插入billing表（PostgreSQL）
   ├─ 插入billing_items表（明细）
   └─ 发送Kafka事件：billing.generated

5. 发送通知
   ├─ 飞书通知租户管理员
   ├─ 邮件发送账单
   └─ 短信提醒

6. 欠费处理
   ├─ 检查历史欠费
   ├─ 超期未付款 → 自动停用租户
   ├─ 发送停用通知
   └─ 记录审计日志

7. 结算完成
```

---

## 四、关键设计决策

### 4.1 为什么采用云边协同？

| 维度 | 边缘端 | 云端 | 原因 |
|------|--------|------|------|
| **数据隐私** | ✅ 本地处理 | - | 视频数据敏感 |
| **实时性** | ✅ <100ms | - | 人脸识别需要低延迟 |
| **带宽成本** | ✅ 避免上传 | - | 日几TB数据 |
| **多租户** | - | ✅ 统一管理 | 数百个社区 |
| **大数据** | - | ✅ 数据汇聚 | 跨社区分析 |
| **运维** | - | ✅ 远程控制 | 统一管理 |

### 4.2 为什么采用微服务架构？

- **职责清晰**：每个服务专注一个领域
- **独立扩展**：根据瓶颈独立扩展
- **故障隔离**：一个服务故障不影响其他
- **技术灵活**：选择最合适的技术栈
- **团队协作**：不同团队独立开发

### 4.3 为什么采用多租户SaaS？

- **商业模式**：共享基础设施，按使用量计费
- **成本优化**：降低运维成本
- **快速扩展**：支持更多客户
- **技术挑战**：数据隔离、性能隔离、安全隔离

### 4.4 为什么使用ThingsBoard？

- **功能完整**：设备管理、双向通信、属性同步
- **成熟稳定**：开源项目，社区活跃
- **MQTT协议**：低带宽、高可靠
- **成本**：开源免费，自己实现成本高

### 4.5 为什么采用分布式事务？

- **场景**：租户创建涉及多个系统
- **问题**：任何一步失败都要完整回滚
- **解决**：事务编排 + 补偿机制

---

## 五、性能优化策略

### 5.1 任务创建优化

**问题**：一次性加载10000+视频，内存2GB，耗时10秒

**解决**：懒加载 + 分页 + LRU缓存
- 创建时只保存参数
- 执行时分页加载
- 缓存热数据

**效果**：内存2GB→50MB，时间10s→500ms

### 5.2 IoT RPC优化

**问题**：同步处理耗时10秒，超时率30%

**解决**：异步处理 + 快速响应
- 快速响应（100ms）：返回"已接受"
- 异步执行：后台创建任务
- 异步通知：通过属性上报结果

**效果**：响应时间10s→100ms，超时率30%→0.5%

### 5.3 视频下载优化

**问题**：并发50路时内存8GB，频繁OOM

**解决**：
- 限制gRPC缓冲区（MaxRecvMsgSize=10MB）
- 对象池复用buffer（sync.Pool）
- 用ISAPI替代CGO（避免SDK泄漏）
- Context控制生命周期
- 优先级队列（6级优先级）

**效果**：内存8GB→2GB，并发30→100+

### 5.4 缓存策略

**多层缓存**：
- L1：本地内存缓存（热数据）
- L2：Redis缓存（分布式）
- L3：数据库（持久化）

**缓存一致性**：
- 双写策略：更新时同时更新数据库和缓存
- Pub/Sub广播：缓存失效通知
- TTL设置：自动过期

---

## 六、可靠性设计

### 6.1 高可用

- **服务冗余**：多个实例，负载均衡
- **健康检查**：定期检查，自动剔除故障实例
- **自动重启**：容器编排自动重启故障服务
- **故障转移**：主从切换，无缝迁移

### 6.2 容错机制

- **限流熔断**：防止级联故障
- **降级策略**：核心功能优先，非核心可降级
- **重试机制**：指数退避，幂等性设计
- **超时控制**：防止无限等待

### 6.3 数据一致性

- **分布式事务**：事务编排 + 补偿机制
- **最终一致性**：Kafka事件驱动
- **幂等性**：支持重试不会产生副作用
- **审计日志**：记录所有关键操作

---

## 七、安全设计

### 7.1 认证授权

- **多因素认证**：用户名密码 + OAuth
- **权限管理**：基于角色的访问控制（RBAC）
- **租户隔离**：网关级别的租户校验
- **Token管理**：JWT + 刷新令牌

### 7.2 数据安全

- **传输加密**：HTTPS/TLS
- **存储加密**：敏感数据加密存储
- **访问控制**：临时签名URL，时间限制
- **审计日志**：记录所有访问

### 7.3 网络安全

- **防火墙**：限制访问范围
- **VPN**：边缘设备与云端加密通信
- **DDoS防护**：限流、黑名单
- **入侵检测**：监控异常流量

---

## 八、可观测性

### 8.1 日志

- **结构化日志**：JSON格式，便于分析
- **日志级别**：DEBUG、INFO、WARN、ERROR、FATAL
- **日志聚合**：ELK Stack（Elasticsearch、Logstash、Kibana）
- **日志保留**：30天热存储，冷存储归档

### 8.2 指标

- **应用指标**：请求延迟、错误率、吞吐量
- **系统指标**：CPU、内存、磁盘、网络
- **业务指标**：租户数、设备数、任务数
- **中间件指标**：数据库连接、缓存命中率

### 8.3 追踪

- **分布式追踪**：Jaeger/Zipkin
- **请求链路**：跟踪请求在各个服务的调用链
- **性能分析**：定位性能瓶颈
- **故障诊断**：快速定位问题

---

## 九、成本优化

### 9.1 基础设施成本

- **资源隔离**：Namespace隔离，防止资源抢占
- **自动扩展**：根据负载自动扩展
- **成本监控**：按租户、按服务统计成本
- **预留实例**：长期稳定负载使用预留实例

### 9.2 存储成本

- **数据分层**：热数据在SSD，冷数据在HDD
- **数据压缩**：视频压缩、日志压缩
- **数据清理**：定期清理过期数据
- **去重**：避免重复存储

### 9.3 带宽成本

- **边缘处理**：本地处理，避免上传
- **数据压缩**：减少传输数据量
- **CDN加速**：加快数据传输
- **流量优化**：避免不必要的传输

---

## 十、总结

这个云边协同系统是一个**企业级、高可用、高性能**的解决方案，涉及：

- **架构设计**：微服务、多租户、云边协同
- **性能优化**：懒加载、异步处理、缓存策略
- **可靠性**：高可用、容错机制、数据一致性
- **安全性**：认证授权、数据加密、审计日志
- **可观测性**：日志、指标、追踪
- **成本优化**：资源隔离、自动扩展、数据分层

这些设计决策都是基于**实际业务需求**和**技术权衡**做出的，体现了系统化的架构思维。

