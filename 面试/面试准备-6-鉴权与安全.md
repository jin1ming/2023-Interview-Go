# 系统鉴权与认证机制 (Identity & Access Management)

## 1. 核心架构
本项目采用了 **Ingress (Kong) + Identity Provider (Keycloak)** 的标准 OIDC 鉴权架构，实现了统一的身份认证和细粒度的权限控制。

*   **Ingress (Kong)**：流量网关，负责请求拦截、HTTPS 卸载、插件执行。
*   **Keycloak**：身份认证中心 (IdP)，负责用户管理、SSO、OAuth2 交互。
*   **OIDC Plugin**：运行在 Kong 上的 Lua 插件，负责 Token 校验、Session 管理和 Header 注入。
*   **Star API**：后端服务，**无状态**，仅依赖 Header 中的身份信息。

---

## 2. 完整的登录鉴权流程

### 场景一：用户登录 (Browser SSO)
**流程目标**：用户通过浏览器访问 Dashboard，使用飞书/账号密码登录。

1.  **拦截**：用户访问 `https://star.nemoface.com`，Kong OIDC 插件拦截请求。
2.  **跳转**：发现无 Session，重定向至 Keycloak 登录页。
3.  **认证**：
    *   用户选择"飞书登录" -> 跳转飞书扫码 -> 飞书回调 Keycloak。
    *   Keycloak 验证身份成功，生成 Authorization Code。
4.  **换票 (Back-channel)**：
    *   浏览器携带 Code 回调 Kong 的 `/callback` 地址。
    *   Kong 后端直接向 Keycloak 发起请求，用 Code 换取 Access/ID/Refresh Tokens。
5.  **建会话**：
    *   Kong 验证 Token 签名。
    *   Kong 将 Token 加密存储在浏览器 **Cookie** 中（Client-side Session）。
6.  **放行**：重定向回用户最初访问的页面。

### 场景二：API 请求鉴权
**流程目标**：边缘设备或第三方系统调用 API。

1.  **携带 Token**：客户端在 Header 中携带 `Authorization: Bearer <JWT>`。
2.  **校验**：
    *   Kong OIDC 插件拦截请求。
    *   本地校验 JWT 签名（公钥从 Keycloak JWKS 获取）。
    *   (可选) 在线调用 Keycloak `introspection_endpoint` 检查 Token 有效性。
3.  **放行**：校验通过，请求转发给后端。

### 场景三：后端交互 (关键解耦设计)
**流程目标**：后端服务如何获取当前用户信息？

1.  **Header 注入**：
    *   Kong OIDC 插件解析 Token/Session 中的 Claims。
    *   将关键身份信息注入到 HTTP Request Header 中：
        *   `X-User-Id`: 用户唯一标识
        *   `X-User-Info`: Base64 编码的完整用户信息 JSON
        *   `tenantId`: 租户标识 (经过权限校验)
2.  **无状态处理**：
    *   后端服务（Star API）**不处理登录逻辑**，**不查用户表**。
    *   直接信任并解析 Request Header，获取当前操作者身份。

---

## 3. 飞书扫码登录实现原理
基于 **OAuth2.0 / OIDC** 的 Identity Broker 模式。

1.  **身份代理**：Keycloak 配置飞书为上游 Identity Provider。
2.  **授权流程**：
    *   Keycloak 生成跳转链接 -> 飞书认证页。
    *   用户扫码 -> 飞书验证 -> 返回 Code 给 Keycloak。
3.  **信息同步**：
    *   Keycloak 用 Code 换取飞书 Access Token。
    *   调用飞书 UserInfo 接口获取姓名、手机号。
    *   **Account Linking**：Keycloak 自动创建或关联本地账号。

---

## 4. 关键技术细节 (面试点)

*   **Session 存储**：
    *   采用 **Client-side Cookie** 模式。Session 数据（Token）加密存储在浏览器 Cookie 中，而非 Redis。
    *   优势：网关无状态，易于水平扩展。
*   **租户权限二次校验 (Motion 定制)**：
    *   在 `utils.lua` 中实现了定制逻辑。
    *   插件会检查请求头中的 `tenantId` 是否包含在用户的 `groups` 列表中，防止越权访问。
*   **Token 刷新**：
    *   OIDC 插件会自动检测 Access Token 有效期。
    *   过期前使用 Refresh Token 自动向 Keycloak 换取新 Token，前端用户无感知。
