# 云边协同系统 - 常见问答集

## 一、架构设计相关问题

### Q1: 为什么采用微服务架构？

**A:** 微服务架构的优势：
1. **职责清晰**：Merak（任务）、Alioth（下载）、Mizar（处理）、Dubhe（管理）
2. **独立扩展**：下载慢只需扩展Alioth，不需扩展整个系统
3. **故障隔离**：视频处理崩溃不影响任务调度
4. **技术灵活**：Go（并发）、C++（性能）、TypeScript（前端）

---

### Q2: 为什么选择gRPC而不是HTTP？

**A:** 
- **性能**：HTTP/2多路复用，Protocol Buffers二进制序列化
- **流式传输**：视频下载需要流式传输大文件
- **类型安全**：编译时检查，避免JSON类型错误
- **资源消耗**：连接复用，内存占用更低

对外API用HTTP是因为前端浏览器只支持HTTP。

---

### Q3: 为什么使用ThingsBoard？

**A:**
- **功能完整**：设备管理、认证、通信、监控开箱即用
- **双向通信**：RPC下发命令，属性上报状态
- **MQTT协议**：低带宽、高可靠，适合物联网
- **成本**：开源免费，自己实现成本高

---

### Q4: 云边端如何通信？为什么不直接HTTP？

**A:**
- **HTTP局限**：边缘设备可能在内网，无公网IP，无法从云端主动连接
- **我们方案**：MQTT + ThingsBoard，边缘端主动连接，云端通过ThingsBoard下发
- **优势**：无需暴露端口、支持离线队列、自动重连、统一管理

---

## 二、多租户架构问题

### Q5: 如何实现多租户数据隔离？

**A:** 三层隔离策略：

1. **数据库层**：所有表添加tenantId字段，复合索引(tenantId, xxx)，Row Level Security
2. **应用层**：中间件自动注入tenantId过滤条件
3. **缓存层**：Redis Key前缀隔离 `tenant:{tenantId}:{key}`
4. **网关层**：Kong插件校验租户ID，防止跨租户访问
5. **存储层**：S3路径隔离 `{tenantId}/{fileName}`

---

### Q6: 租户启用后丢失信息怎么解决？

**A:** 这是真实生产问题（Issue #832bcfed8）。

**原因**：租户信息缓存在Redis，状态变更时缓存未及时刷新，CDC消息延迟

**解决**：双写策略 + Pub/Sub广播
- 更新数据库
- 同步更新Redis缓存
- 发送CDC消息（兜底）
- Redis Pub/Sub广播缓存失效

**效果**：缓存一致性99.99%

---

### Q7: 租户创建为什么需要分布式事务？

**A:** 涉及多个系统：PostgreSQL、Keycloak、ThingsBoard、聚类引擎

任何一步失败都要完整回滚，避免"半成品"租户。

**解决**：事务编排 + 补偿机制
- 数据库事务保证PostgreSQL一致性
- 补偿机制清理外部资源
- 详细日志便于排查
- 幂等性设计支持重试

---

## 三、性能优化问题

### Q8: 任务创建为什么慢？如何优化到500ms？

**A:** 
**问题**：一次性加载10000+个视频文件，内存2GB，耗时10秒

**解决**：懒加载 + 分页 + LRU缓存
- 创建时只保存参数，不加载视频
- 执行时分页加载（每页100个）
- LRU缓存热数据

**效果**：
- 内存：2GB → 50MB（降低96%）
- 时间：10s → 500ms（提升20倍）
- GC频率：降低80%

---

### Q9: IoT RPC为什么超时？如何优化到100ms？

**A:**
**问题**：同步处理耗时10秒，ThingsBoard超时10秒，失败率30%

**解决**：异步处理 + 快速响应
- 快速响应（100ms）：返回"已接受"
- 异步执行：后台创建任务
- 异步通知：通过属性上报结果

**效果**：
- 响应时间：10s → 100ms（提升100倍）
- 超时率：30% → 0.5%
- 成功率：99.5%+

**关键代码**：
```go
func handleCreateTask(msg RpcMessage) {
  quickResp := buildAcceptedResponse(msg.RequestId)
  go func() {
    task := createTask()
    notifySuccess(task)
  }()
  return quickResp
}
```

---

### Q10: 视频下载内存泄漏如何优化？

**A:**
**问题**：50个摄像头，并发50路时内存8GB，频繁OOM

**解决**：
1. **限制gRPC缓冲区**：MaxRecvMsgSize=10MB
2. **对象池复用buffer**：sync.Pool避免频繁分配
3. **用ISAPI替代CGO**：避免海康SDK内存泄漏
4. **Context控制生命周期**：防止goroutine泄漏
5. **优先级队列**：6级优先级调度

**效果**：
- 内存：8GB → 2GB（降低75%）
- 并发：30 → 100+（提升3倍）
- 稳定性：30天+无重启

---

## 四、技术深度问题

### Q11: 如何处理并发安全？

**A:** 常见问题和解决方案：

**Map竞态**：使用sync.Map（读多）或sync.RWMutex（写多）

**Goroutine泄漏**：使用Context控制生命周期
```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

go func() {
  select {
  case <-ctx.Done():
    return
  default:
    doSomething()
  }
}()
```

**Channel泄漏**：发送端关闭channel
```go
go func() {
  ch <- 1
  close(ch)  // 只在发送端关闭
}()
```

**定时器泄漏**：调用Stop()
```go
ticker := time.NewTicker(1 * time.Second)
defer ticker.Stop()
```

---

### Q12: 如何定位内存泄漏？

**A:** 使用pprof：

```bash
# 采集heap快照
curl http://localhost:6060/debug/pprof/heap > heap.prof

# 分析
go tool pprof -http=:8080 heap.prof

# 采集goroutine快照
curl http://localhost:6060/debug/pprof/goroutine > goroutine.prof

# 对比两个快照
go tool pprof -base heap1.prof heap2.prof
```

常见泄漏模式：
- 未关闭的文件/数据库连接
- 未取消的Context
- 未停止的定时器
- 未关闭的channel

---

### Q13: 如何保证系统高可用？

**A:**
1. **服务冗余**：多个实例，负载均衡
2. **健康检查**：定期检查服务状态，自动剔除故障实例
3. **限流熔断**：防止级联故障
4. **降级策略**：核心功能优先，非核心功能可降级
5. **监控告警**：Prometheus + Grafana + 飞书告警
6. **自动重启**：容器编排自动重启故障服务

---

## 五、业务逻辑问题

### Q14: 如何处理视频检索任务的完整流程？

**A:**
1. **用户发起检索**：查询人员特征向量，通过IoT下发任务
2. **Dipper接收**：快速响应，异步创建任务
3. **任务执行**：分页加载视频 → 下载 → 处理 → AI推理 → 保存结果
4. **实时上报**：进度、结果通过属性上报到云端
5. **用户查看**：从ClickHouse查询结果，生成临时签名URL

---

### Q15: 结算系统如何工作？

**A:**
1. **月底生成账单**：统计设备使用天数，按规则计费
2. **发送通知**：飞书通知租户
3. **欠费预警**：超期未付款发送告警
4. **自动停用**：超过信用额度自动停用租户

---

## 六、面试官可能的追问

### Q16: 如果重新设计，会有什么改进？

**A:**
1. **引入消息队列**：解耦RPC调用，提高吞吐量
2. **事件驱动架构**：降低服务耦合
3. **更细粒度微服务**：拆分Merak为多个服务
4. **服务网格**：使用Istio管理通信
5. **CQRS模式**：读写分离，提高性能

---

### Q17: 遇到过最难的bug是什么？

**A:** 间歇性内存泄漏，运行3-5天后OOM

**排查**：
- pprof采集heap快照
- 发现goroutine数量持续增长
- 发现context没有cancel导致泄漏

**解决**：
```go
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
defer cancel()  // 必须调用
```

---

### Q18: 如何保证代码质量？

**A:**
1. **代码审查**：必须1人Review并Approve
2. **自动化测试**：70%+覆盖率
3. **静态分析**：golangci-lint、race detector
4. **CI/CD自动化**：自动测试、构建、部署
5. **监控告警**：Prometheus + Grafana + 飞书

---

### Q19: 如何处理生产环境的问题？

**A:**
1. **快速定位**：日志分析、监控指标、追踪
2. **临时方案**：快速止血，恢复业务
3. **根本解决**：从根因出发，避免治标不治本
4. **预防措施**：添加监控、自动化测试、Code Review

---

### Q20: 项目中学到了什么？

**A:**
1. **架构设计**：微服务、云边协同、多租户
2. **性能优化**：pprof、内存管理、并发编程
3. **系统设计**：高并发、高可用、可扩展
4. **工程实践**：CI/CD、监控告警、Code Review
5. **问题解决**：系统性分析、从根因出发

