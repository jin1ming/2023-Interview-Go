- i++为什么不是线程安全的
  - 底层经历了读取数据、更新CPU缓存、存入内存等操作
  - 编译器编译和CPU处理时通过调整指令顺序进行优化
  - 锁
    - 原子锁/自旋锁:
      - `atomic.CompareAndSwapInt64(&flag), 0, 0)`
      - 缺点：1.CPU开销大；2.不能保证代码的原子性；3.ABA问题（版本号+时间戳解决）
    - 互斥锁：
      - sync.Mutex 更轻量级的锁，解决原子锁CPU开销大的问题。
      - 实现：
        ```go
        type Mutex struct {
           state int32 // 锁状态
           sema uint32 // 信号量
        }
        ```
        state锁状态为互斥锁位图，包含：
        - 1.正在等待被唤醒的协成数量；
        - 2.当前进入饥饿状态；
        - 3.协成准备从正常状态下被唤醒；
        - 4.锁定状态
        
        阶段：
        1. CAS快速抢占锁。成功就返回，失败调用lockSow。
           - lockSlow正常情况下会自旋尝试抢占锁一段时间，不立即进入休眠状态。
           - 存在4种情况，自旋终止：
             - 单核CPU
             - 逻辑处理器小于等于1
             - 当前协成所在逻辑处理器的本地队列上有其它协成待运行。
             - 自旋次数超过了设定的阈值
        2. 
    - 读写锁
      - 1