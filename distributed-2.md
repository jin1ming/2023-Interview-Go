- 什么是分布式事务？

​		二阶段提交、三阶段提交

- 分布式锁有哪些实现方式？分别会存在什么问题，哪种实现更好？

​		zk(ZooKeeper)锁实现原理：
​		（1）创建一个目录mylock；
​		（2）线程A想获取锁就在mylock目录下创建临时顺序节点；
​		（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
​		（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
​		（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

- redis事务：
  	1、事务提供了一种将多个命令打包，然后一次性有序（FIFO）执行的机制
  	2、事务执行过程不会被中断
  	3、带WATCH命令的事务会将客户端和被监视的键在数据库watched_keys字典中进行关联，当键被修改程序会将所有监视键的客户端REDIS_DIRTY_CAS标识打开
  	4、在客户端提交EXEC命令时，会检查REDIS_DIRTY_CAS标识，标识打开事务将不会被执行
  	5、Redis事务具有ACID的特性（当服务器运行在AOF模式下，并且appendfsync选项值为always时才具有持久性

- redis 实现分布式锁:
  2.6.12版本之后命令： SET key value EX 10 NX  （合并了1、2两个步骤）
  核心思路：
  1、使用setnx设置互斥锁
  2、为了避免异常情况导致死锁，因此需要为锁设置过期时间
  3、为了避免删锁混乱，导致锁永久失效，需要为每个请求分配唯一的value值，再删锁时，验证是否属于自身的锁。
  4、为了避免在删锁的操作过程中的异常情况，如锁过期，新的请求获得锁，此时删除的是新的锁。可以再执行任务中新启一个协程每隔10s去检查主程是否还持有锁，如果还持有锁，则为锁进行续期。
  基于lua脚本实现redis的乐观锁