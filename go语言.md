# golang

目录：

[TOC]

---

## 基础

### 数组和切片有什么区别？

- go语言中数组是一种值类型，[2]int和[3]int是两种不同的类型；切片类型只和它的基础数据类型有关，如[]int和[]string.

- 数组本身的赋值和传参都是以整体复制进行处理的；而切片复制的只有切片头部分信息，因为包含底层数据指针。

- 切片可以扩容

- 切片基于数组：

  ```
  type SliceHeader struct {
    Data uintptr
    len int
    Cap int
   }
  ```

### 字符串和数组有什么区别？

  - 字符串底层数据是对应的字节数组，但字符串的只读属性禁止了在程序中对字节数组的元素进行修改。
  - 字符串赋值只复制了数据地址和对应的长度，不会复制底层数据。（使用不当会造成内存泄漏）

### new和make区别

- make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据；
- new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type；
- new 分配的空间被清零。make 分配空间后，会进行初始化；

### 进程、线程、协程区别

- 进程是应用程序的实体，分配操作系统资源的最小单位，拥有自己的内存空间以及堆栈。

- 线程是内核操作系统调度CPU的基本单位，在进程的内存空间及堆栈上进行执行运行。

- 协程指的是用户态线程，由用户的应用程序进行调度 

  一般协程利用多核优势采用进程+协程，go协程采用内核线程+协程实现

### 协程的好处

a. 切换上下文代价小，协程切换时不用进行系统调用，走内核态的指令。

b. 没有多线程的竞争资源锁问题，多线程竞争资源还会锁内存走系统调用，而协程如果竞争资源直接在当前线程上的进行判断就可以了 

c.内存占用小，只占用 2K，线程占用 2M

### CSP并发模型(通信顺序进程)

不要通过共享内存来通信，而要通过通信来实现内存共享。

​	CSP并发模型它并不关注发送消息的实体，而关注的是发送消息时使用的channel，go语言借用了process和channel这两个概念，process表现为go里面的goroutine，是实际并发执行的实体，每个实体之间是通过channel来进行匿名传递消息使之解藕，从而达到通讯来实现数据共享。

​	同时，借助Go语言调度器的设计，可以高效实现通道的堵塞/唤醒，进一步实现通道多路复用的机制。

​	另外与select结合，可以避免由于一个通道的读写陷入阻塞。

## 锁

### golang有哪些锁？

原子锁、互斥锁、读写锁

### 原子锁/自旋锁:

- `atomic.CompareAndSwapInt64(&flag), 0, 0)`
- 缺点：1.CPU开销大；2.不能保证代码的原子性；3.ABA问题（版本号+时间戳解决）

### 互斥锁：

混合公平锁，结合了原子操作、自旋、信号量、全局哈希表、等待队列、操作系统级别锁。

- 包含了Lock和TryLock两种调用

- 另种模式：正常模式、饥饿模式（1ms没获取到锁）

- sync.Mutex 更轻量级的锁，解决原子锁CPU开销大的问题。

- 实现：
  ```go
  type Mutex struct {
     state int32 // 锁状态
     sema uint32 // 信号量
  }
  ```
  state锁状态为互斥锁位图（默认都为0），包含：
  - 1.waiterCount:正在等待被唤醒的协成数量；
  - 2.starving:当前进入饥饿状态；
  - 3.woken:协程准备从正常状态下被唤醒；
  - 4.locked:锁定状态

  上锁阶段：
  1. CAS快速抢占锁。成功就返回，失败调用lockSow。
     - lockSlow正常情况下会自旋尝试抢占锁一段时间，不立即进入休眠状态。
     - 存在4种情况，自旋终止：单核CPU、逻辑处理器小于等于1、当前协成所在逻辑处理器的本地队列上有其它协成待运行、自旋次数超过了设定的阈值
     
  2. 信号量同步。
  
     加锁信号量-1，解锁信号量+1
  
  3. 所有锁存储在全局semtable哈希表。
  
  释放阶段：
  
  1. 普通状态（非饥饿和唤醒）：Unlock()使用atomic.Addint32修改状态。否则，调用unlockSlow()。
  
  2. 判断是否重复释放。
  
  3. 饥饿状态：进入信号量同步阶段，全局哈希表寻找锁等待队列，先入先出顺序唤醒指定协程。
  
  4. 非饥饿状态：
  
     如果互斥锁不存在等待者或者互斥锁的 `mutexLocked`、`mutexStarving`、`mutexWoken` 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；
  
     如果互斥锁存在等待者，会通过`runtime_Semrelease`唤醒等待者并移交锁的所有权。

### 读写锁

```go
type RWMutex struct {
	w           Mutex  // held if there are pending writers
	writerSem   uint32 // semaphore for writers to wait for completing readers
	readerSem   uint32 // semaphore for readers to wait for completing writers
	readerCount int32  // number of pending readers
	readerWait  int32  // number of departing readers
}
```

## GMP模型

  - M(machine): 线程
  - P(processor): 处理器（调度器、非CPU），代表着运行Go代码的必要资源，以及调度goroutine的能力。
  - G(gooutine): Go协程，轻量级用户线程。
  - 关于M的数目：
    M的个数是根据实际情况自行创建的，一般稍大于P的个数，为了保证runtime包的内置任务的运行。在运行中不够用时，也会再重新创建一个。
  - 关于P的数目：
    P的个数默认为CPU的核数，在IO密集的场景下可以适当提高P的个数。设置方式有两种，例：
    设置环境变量:export GOMAXPROCS=80 或者 runtime.GOMAXPROCS(80)
  - 另外还有全局runqueue队列存在：全局队列由多个处理器共享，访问通过互斥锁来完成。
    处理器P中的协程G额外再创建的协程会加入到本地的runqueues中。
    两种情况下会放入全局队列中：1. 本地队列已满 2. 阻塞的协程被唤醒
    全局队列会被处理器P周期性的摘取来调度。
  - 调度策略
    - 队列轮转
    - 系统调用
    - 工作量窃取
    - 抢占式调度

### GPM中有什么组件

​	除开 GMP ，还有 P 的 G 本地队列， G 的全局队列，P 列表（MAXPROCS 决定），M 列表（最大限定 1W，runtime/debug 可以设置） 

### GMP 模型中为什么需要 P

- 假设没有 P 会发生什么事情，（没有 P 本地队列，没有 P 全局队列）

  a. 出现资源竞争，由于没有 P 的本地以及全局队列的多级缓存，所以 G 都会放在一起，多个 M 去获取时会出现资源竞争

  b. 协程切换资源消耗大，由于没有 P ，也没有 g0 去负责切换协程堆栈，相当于协程堆栈以及一些运行现场全部都在内核态去维护 

  c. 系统调用阻塞时切换成本高，M 会经常被阻塞和解阻塞切换内核态和用户态（类似于进程间切换），消耗大


- 引入了 P 相当于解决了上面的大部分问题，甚至引入了新的特性去榨干 CPU 的性能

  a. 引入本地队列和全局队列做多级缓存，获取 G 时都会从本地队列获取，没有竞争，就算去全局队列获取也比较少的几率出现大量 P 去获取，降低了资源竞争的概率

  b. 切换协程堆栈效率提高，使用了 g0 的协程负责去管理协程切换的堆栈以及保护现场的工作，进入内核态去切换的时候少了很多切换指令以及寄存器的使用，甚至引入了 g0 去负责做垃圾回收部分工作的职能 

  c. 系统调用的曲线救国方案，当 G 和 M 发生了系统调用时，P 会解绑 M ，带着本地队列的 P 去找空闲的 M 或者新创建的 M 去继续剩下的工作 还引入了「工作窃取」的功能，让基于和 M 绑定的 P 更加灵活的让每个 M 都能够最大限度的运行 task，榨干 CPU 

### P 调度器的设计策略

- 线程复用、并行
- work stealing 工作窃取机制：当 P 本地队列无运行 G 时，会去其他线程绑定的 P 窃取 G ，若其他 P 本地队列也没有时会去 G 全局队列进行窃取
- hand off 分离机制：当 G 因为系统调用阻塞时，P 会和 M 解绑，将 G 和 M 绑定，P 会和空闲的线程进行绑定

- 主动让出机制：当 G 占用了 CPU 超过 10MS 会主动让出（sysmon 轮询） 

## Channel

### channel底层的数据结构是什么？发送和接收元素的本质是什么？

```go
type hchan struct {
    qcount   uint           // *chan里元素数量
    dataqsiz uint           // *底层循环数组的长度，就是chan的容量
    buf      unsafe.Pointer // *指向大小为dataqsiz的数组，有缓冲的channel
    elemsize uint16         // chan中的元素大小
    closed   uint32         // chan是否被关闭的标志
    elemtype *_type         // chan中元素类型
    recvx    uint           // *当前可以接收的元素在底层数组索引(<-chan)
    sendx    uint           // *当前可以发送的元素在底层数组索引(chan<-)
    recvq    waitq          // 等待接收的协程队列(<-chan)
    sendq    waitq          // 等待发送的协程队列(chan<-)
    lock     mutex          // 互斥锁,保证每个读chan或者写chan的操作都是原子的
}

// waitq是sudog的一个双向链表，sudog实际上是对goroutine的一个封装。
type waitq struct {
	first *sudog
	last  *sudog
}

// channel的发送和接收操作本质上都是"值的拷贝"(只是拷贝它的值而已)，
```

### channel使用应该注意哪些情况，在哪些情况下会死锁/阻塞？
​	1、一个无缓冲channel在一个主go程里同时进行读和写；
​	2、无缓冲channel在go程开启之前使用通道；
​	3、通道1中调用了通道2，通道2中调用了通道1；
​	4、读取空的channel；
​	5、超过channel缓存继续写入数据；
​	6、向已经关闭的channel中写入数据不会导致死锁，但会Panic异常。
​	7、close一个已经关闭的channel会Panic异常。

## Map

### map的底层实现原理是什么？

```
type hmap struct {
    count      int   // len(map)元素个数
    flags      uint8 // map当前状态：写标志位等
    B          uint8 // buckets长度是2^B
    noverflow  uint16 // 溢出桶的数量
    hash0      uint32 // 随机种子
    buckets    unsafe.Pointer // 指向buckets数组
    oldbuckets unsafe.Pointer // 扩容的时候，buckets长度会是oldbuckets的两倍
    nevacuate  uintptr // 扩容时使用，标记当前旧桶中小于该值的数据完成转移
    extra      *mapextra // 存储map中的溢出桶
}

// 编译期间动态创建的bmap
type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}

type mapextra struct {
	overflow    *[]*bmap
	oldoverflow *[]*bmap
	nextOverflow *bmap
}
```
在go中map是数组存储的，采用的是哈希查找表，通过哈希函数将key分配到不同的bucket。

每个bucket中可以存储8个kv键值对，当每个bucket存储的kv对到达8个之后，会通过overflow指针指向一个新的bucket，从而形成一个链表。

### map的存储是有序的吗

存储结构上由于在扩容的时候会将 key 随机分流到另外两个桶，这导致了 key  的相对位置会发生改变，所以 key 是无序的。

遍历上来说，每次遍历是取一个随机数，随机从一个桶开始遍历。所以每次遍历出来的结果都是不一样的。

额外一点是，当未发生扩容前，key 的相对位置是确定的。

### map的key的定位过程是怎样的？
​	对key计算hash值，计算它落到那个桶时，只会用到最后B个bit位，再用哈希值的高8位找到key在bucket中的位置。桶内没有key会找第一个空位放入，冲突则从前往后找到第一个空位。

### map的扩容和缩容

**扩容**分为了翻倍扩容、等量扩容。还有确定了要扩容后，使用的是渐进式扩容去避免性能抖动。

扩容的触发条件有两个，**状态装载因子超过 6.5**（现在的桶装在的元素超过 80 %），也就是元素太多了，或者**溢出桶太多**，也就是太多元素被删除，元素非常稀疏。 前者会使用翻倍扩容，会申请现有翻倍的空间。当有读操作时仍会访问旧桶，当有插入或者删除操作的时候会将旧桶分流到两个新桶。后者会使用等倍扩容，重新申请一块和现有大小相同的新桶，也是使用渐进式扩容在插入或者删除操作中进行。

go 的 map 没有缩容的机制。map 内部的存储结构是基于拉链法的，里面的元素如果被大批量的删除后，会触发等量扩容。等量扩容时会申请原有大小一样的内存块，渐进式的扩容过去，让原有的 map 中因为很多元素被删除后导致元素排序稀疏的情况经过 rehash 后会排序会变得紧密，减少溢出桶的使用

## GC

- 常见的GC实现方式有哪些？

  - 标记-清扫（三色标记）：缺点为有内存碎片

    - 白色，初始值。本次回收没被扫描过的对象默认都是白色的。而确认不可达的对象也是白色，但是会被标记「不可达」。
    - 灰色，中间状态。本对象有被外部引用，但是本对象引用的其它对象尚未全部检测完。
    - 黑色，本对象有被其它对象引用，且已检测完本对象引用的其它对象。

  - 标记-压缩

    解决了内存碎片问题，但会破坏缓存局部性，且需要额外空间来标记移动。

  - 半空间复制

    空间换时间，保留一般的内存空间用于快速压缩内存。

  - 引用计数

    必须原子更新，并发困难。

  - 分代GC

    按照存活时间划分，前提是死去的对象一般都是新创建不久。

    不反复扫描旧对象，加快了gc速度和吞吐量，减少stw。

    但没办法及时回收老一代对象，需要额外开销区分新老对象。

- go的GC有那三个阶段？流程是什么？如果内存分配速度超过了标记清除速度怎么办？

  goV1.8三色+混合写屏障机制，栈不启动屏障，流程如下：
  	1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行重复扫描，无需STW)；
  	2、GC期间，任何在栈上创建的新对象均标记为黑色；
  	3、被删除的对象和被添加的对象均标记为灰色；
  	4、回收白色集合中的所有对象。

  总结：
  	v1.3普通标记清除法，整体过程需要STW，效率极低；
  	v1.5三色标记法+屏障，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通；
  	v1.8三色标记法+混合写屏障，**消除栈的重扫过程，因为一旦栈被扫描变为黑色，则它会继续保持黑色， 并要求将对象分配为黑色**。堆空间启动，栈空间不启动屏障，整体过程几乎不需要STW,效率较高。

  ​	如果申请内存的速度超过预期，运行时就会让申请内存的应用程序辅助完成垃圾收集的扫描阶段，在标记和标记终止阶段结束之后就会进入异步的清理阶段，将不用的内存增量回收。并发标记会设置一个标志，并在mallocgc调用时进行检查，当存在新的内存分配时，会暂停分配内存过快的哪些goroutine，并将其转去执行一些辅助标记的工作，从而达到放缓内存分配和加速GC工作的目的。

## 其他

### 内存泄漏场景，及如何解决？

  - 切片/字符串引用不当：先对需要引用的进行拷贝，再引用
  - 频繁的系统调用
  - for循环中使用defer：在for中构建一个局部函数，在函数内部执行defer
  - goroutine泄露
    如：Ticker使用忘记Stop，通常使用context来避免。

解决：

​	1、通过pprof工具获取内存相差较大的两个时间点heap数据。htop可以查看内存增长情况。
​	2、通过go tool pprof比较内存情况，分析多出来的内存。
​	3、分析代码、修复代码。

### Context

  context包是Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体，是开发常用的并发控制技术。

  与WaitGroup的不同在于context可以控制多级的goroutine。

  Context是线程安全的。 

作用：

- 传递上下文。不推荐传递业务参数，常用来传递整个链路的trace id来作为链路追踪
- 协程间同步信息。比如在协程树中传递取消信号。

### Gin的启动过程

项目的main函数

主函数位于项目根目录下的main.go中，代码如下：

```
package main

import (
	"github.com/LearnGin/handler"
	"github.com/LearnGin/middleware"
	"github.com/gin-gonic/gin"
)

func main() {
	// init gin with default configs
	r := gin.Default()

	// append custom middle-wares
	middleware.RegisterMiddleware(r)
	// register custom routers
	handler.RegisterHandler(r)

	// run the engine
	r.Run()
}
```

主要步骤：

1. 初始化Gin

   ```
   gin.Default()
   ```

   执行Gin的初始化过程，默认的初始化包含两个中间件，

   1. **Logger**：日志中间件，将Gin的启动与响应日志输出到控制台；
   2. **Recovery**：恢复中间件，将Gin遇到的无法处理的请求按HTTP 500状态码返回。

2. **注册中间件**：本例的`middleware.RegisterMiddleware(r)`用于将项目中开发的中间件注册到Gin Engine上；

3. **注册事件处理**：本例的`handler.RegisterHandler(r)`用于将项目中开发的对应于指定URL的事件处理函数注册到Gin Engine上；

4. **启动Gin**：`r.Run()`负责启动Gin Engine，开始监听请求并提供HTTP服务。

### iface和eface的区别是什么？值接收者和指针接收者的区别？
​	iface和eface都是Go中描述接口的底层结构体，区别在于iface包含方法。而eface则是不包含任何方法的空接口：interface{}

​	注意：编译器会为所有接收者为T的方法生成接收者为*T的包装方法，但是链接器会把程序中确定不会用到的方法都裁剪掉。因此*T和T不能定义同名方法。
​	生成包装方法是为了接口，因为接口不能直接使用接收者为值类型的方法。
​	如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。
​	如果类型具备"原始的本质"，如go中内置的原始类型，就定义值接收者就好。
​	如果类型具备"非原始的本质"，不能被安全的复制，这种类型总是应该被共享，则可定义为指针接收者。
