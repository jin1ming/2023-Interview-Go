package algorithms

import "math/bits"

// 上一次学习：2022.7.20

/***** 只出现一次的数字 *****/
// 给定一个非空整数数组，除了某个元素只出现一次以外，
// 其余每个元素均出现两次。找出那个只出现了一次的元素。
// 算法思路：利用异或运算的性质
// 1. 任何数和 0 异或等于它本身：a ^ 0 = a
// 2. 任何数和自身异或等于 0：a ^ a = 0
// 3. 异或运算满足交换律和结合律
// 因此，所有出现两次的数字异或后都会变成 0，最后只剩下出现一次的数字
func singleNumber(nums []int) int {
	single := 0
	for _, num := range nums {
		// 出现两次的数字会抵消为 0
		// 最后剩的就是最终的结果
		single ^= num
	}
	return single
}

/***** 汉明距离 *****/
// 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目
// 算法思路：先对 x、y 进行异或，找出二进制下不同的位（异或结果为 1 的位）
// 然后统计异或结果中 1 的个数即可
func hammingDistance(x int, y int) int {
	// 先对x、y进行异或，找出二进制下不同的值
	// 不同的即为1， 统计1出现的次数即可
	return bits.OnesCount(uint(x ^ y))
}

/***** 两整数之和 *****/
// 不允许使用 +、- 运算符，计算两整数之和
// 算法思路：使用位运算模拟加法
// a + b 的问题拆分为 (a 和 b 的无进位结果) + (a 和 b 的进位结果)
// 无进位结果：a ^ b（异或运算）
// 进位结果：(a & b) << 1（与运算后左移一位）
// 时间复杂度 O(logSum) | 空间复杂度 O(1)
func getSum(a int, b int) int {
	// 异或+与运算:时间复杂度O(logSum) | 空间复杂度O(1)
	// a + b 的问题拆分为 (a 和 b 的无进位结果) + (a 和 b 的进位结果)
	// 最后这个 + 再用无进位结果（异或）来表示
	// a, b = a^b, (a&b)<<1
	for b != 0 {
		// a 存储无进位结果，b 存储进位结果
		// 不断迭代直到进位为 0
		a, b = a^b, (a&b)<<1
	}
	return a
}

/***** 1～n 整数中 1 出现的次数 *****/
// 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数
// 算法思路：按位统计，对于每一位（个位、十位、百位...），计算该位上 1 出现的次数
// 将数字分为三部分：高位(high)、当前位(cur)、低位(low)
// 根据当前位的值分三种情况计算：
// 1. cur == 0: 该位 1 的个数 = high * digit（只看高位）
// 2. cur == 1: 该位 1 的个数 = high * digit + low + 1（高位 + 低位+1）
// 3. cur > 1: 该位 1 的个数 = high * digit + digit（高位+1后乘以digit）
func countDigitOne(n int) int {
	var cur, res, high, digit, low int
	// 初始化：从个位开始
	high = n / 10 // 高位（去掉个位）
	cur = n % 10  // 当前位（个位）
	digit = 1     // 当前位的权重（个位为1）

	// 从个位到最高位逐位统计
	for high > 0 || cur > 0 {
		switch cur {
		case 0:
			// 当前位为 0，该位 1 的个数只由高位决定
			// 例如：2304 的十位，十位为 1 的数字范围是 10-19, 110-119, ..., 2210-2219
			// 共 high * digit 个
			res += high * digit // 只看高位
		case 1:
			// 当前位为 1，该位 1 的个数由高位和低位共同决定
			// 例如：2314 的十位，十位为 1 的数字范围是 10-19, 110-119, ..., 2310-2314
			// 共 high * digit + low + 1 个
			res += high*digit + low + 1 // 高位 + low+1 (0-low)
		default:
			// 当前位大于 1，该位 1 的个数由高位决定（高位+1）
			// 例如：2324 的十位，十位为 1 的数字范围是 10-19, 110-119, ..., 2310-2319
			// 共 (high + 1) * digit 个
			res += high*digit + digit
		}
		// 移动到下一位
		cur = high % 10         // 当前位更新为高位的个位
		low = n - high*digit*10 // 低位 = 原数 - 高位*权重*10
		digit *= 10             // 权重乘以 10
		high /= 10              // 高位去掉个位
	}
	return res
}
