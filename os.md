# 操作系统

#### 1. 操作系统基本特征

1. **并发**

   - 并发是指宏观上在一段时间内能同时运行多个程序。
   - 操作系统通过引入进程和线程，使得程序能够并发执行。

2. **共享**

   - 共享是指系统中的资源可以被多个并发进程共同使用。
   - 有两种共享方式：互斥共享和同时共享。
   - 互斥共享的资源称为临界资源。例如打印机，在同一时刻只允许一个进程访问。
   - 实现互斥访问需要用到进程同步机制。

3. **虚拟**

   虚拟技术把**一个物理实体**映射为**多个逻辑实体**。

   - 主要有两种虚拟技术：**时（时间）分复用技术**和**空（空间）分复用技术**。
   - **时分复用技术**：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
   - **空分复用技术**：虚拟内存使用了空分复用技术。它将物理内存抽象为地址空间，每个进程都有各自的地址空间。
     - 地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中。
     - 当使用到一个不在物理内存的页时，执行页面置换算法，将该页置换到内存中。

4. **异步**

   异步是指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

**follow-up：并发和并行的区别？**

- 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。
- 并行需要硬件支持。如多流水线、多核处理器或者分布式计算机系统。



#### 2. 操作系统基本功能

1. **进程管理**

   进程控制、进程同步、进程通信、死锁处理、处理机调度等。

2. **内存管理**

   内存分配、地址映射、内存保护与共享、虚拟内存等。

3. **文件管理**

   文件存储空间的管理、目录管理、文件读写管理和保护等。

4. **设备管理**

   完成用户的`I/O`请求，方便用户使用各种设备，并提高设备的利用率。

   主要包括缓冲管理、设备分配、设备处理、虚拟设备等。



#### 3. 进程、线程、协程

**进程**

- **定义**：进程是操作系统资源分配的基本单位。
- **拥有资源**：操作系统给进程分配`CPU`资源、内存资源、文件资源和句柄等资源。
- **切换情况 / 切换者**：进程切换时，需要保存进程的`CPU`环境（栈、寄存器、页表和文件句柄等），还要设置新调度的进程的`CPU`环境。 切换者是操作系统。
- **并发性**：不同进程之间切换实现了并发，进程各自占有`CPU`则可以实现并行。
- **系统开销**：切换虚拟地址空间，切换内核栈和硬件上下文，`CPU`高速缓存失效，还要切换页表，开销较大。
- **通信方面**：进程间通信需要借助操作系统。

**线程**

- **定义**：线程是程序执行的基本单位。
- **拥有资源**：一个线程独享程序计数器、寄存器、栈和状态字。
- **切换情况 / 切换者**：切换线程只需要保存和设置程序计数器、少量寄存器和栈的内容（因此相比切换进程，开销要小）。 切换者也是操作系统。
- **并发性**：一个进程内部的多个线程并发执行。
- **系统开销**：切换线程时只需要保存和设置少量寄存器内容，因此开销很小。
- **通信方面**：线程间可以直接读写进程数据段（如全局变量）来进行通信。

**协程**

- **定义**：协程是用户态的轻量级线程，是线程内部调度的基本单位。
- **拥有资源**：协程拥有自己的寄存器上下文和栈。
- **切换情况 / 切换者**：切换协程时，先保存寄存器上下文和栈，等切换回来的时候再恢复。  切换者是用户。
- **并发性**：同一时间只能执行一个协程，而其他协程处于休眠状态。
- **系统开销**：直接操作栈则基本没有内核切换的开销，可以不加锁访问全局变量，所以上下文的切换非常快。
- **通信方面**：协程间通信可以使用共享内存和消息队列。

进程、线程、协程对比图：

![image-20210407161821704](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407161821704.png)



#### 4. 进程与线程的区别

线程具有许多传统进程所具有的特征，故又称为轻型进程。

在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。

1. **根本区别**：进程是操作系统资源分配的基本单位。线程是处理器任务调度和执行的基本单位。
2. **资源开销**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销，需要分配和回收内存空间、`I/O`设备等资源。线程可以看作轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（`PC`），线程之间切换的开销小，线程切换时只需保存和设置少量的寄存器内容。
3. **包含关系**：线程是进程的一部分。
4. **内存分配**：不同进程之间的地址空间和资源是相互独立的。而同一进程内的线程间共享本进程的地址空间和资源。
5. **影响关系**：一个进程崩溃后，在保护模式下不会对其他进程产生影响。但是一个线程崩溃则整个进程都会死掉。所以多进程要比多线程更健壮。
6. **执行过程**：两者均可并发执行。每个独立的进程都有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程的执行控制。
7. **通信方面**：进程之间通信需要借助`IPC`。线程间可以通过直接读写同一进程中的数据进行通信。

**follow-up：线程共享的资源有哪些？独占的资源有哪些？**

- 同一进程的线程间**共享**的资源有**堆、全局变量、静态变量、指针、引用、文件等**。
- 线程**独占**的有：栈。

**follow-up：父子进程**

- 在`Unix / Linux`中，正常情况下，子进程是通过父进程创建的。
- 子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。
- 当一个进程完成它的工作，终止运行之后，它的父进程需要调用`wait()`或者`waitpid()`系统调用获得子进程的终止状态。

**follow-up：进程创建过程**

系统调用：**fork()函数**

- 在`Unix`系统中，只有一个系统调用可以用来创建新进程：`fork`。
- 这个系统调用会创建一个与调用进程相同的副本。
- **在调用了`fork`后，这两个进程（父进程和子进程）拥有相同的存储映像、同样的环境字符串和同样的打开文件**。
- `fork`刚完成时，父子进程的**内存、寄存器、程序计数器**都是完全一样的。
- `fork()`函数调用一次，返回两次。
  - 对于父进程：`fork`的返回值为子进程的`PID`。
  - 对于子进程：`fork`的返回值为`0`。

**follow-up：线程回收方法**

1. **等待线程结束**：

   方法：`int pthread_join(pthread_t tid, void** retval);`

   - 主线程调用这个方法，等待子线程退出，并回收其资源。
   - 这个方法类似于进程中的`wait / waitpid`方法回收僵尸进程。
   - 调用`pthread_join`的线程会被阻塞。
   - 方法传入参数：
     - `tid`：创建线程时通过指针得到的`tid`值，线程的`id`。
     - `retval`：指向返回值的指针。

2. **结束线程**：

   方法：`pthread_ext(void *retval);`

   - 这个方法由子线程执行，用来结束当前线程并通过`retval`传递返回值。
   - 该返回值可以通过`pthread_join`获得。
   - 这个方法的参数`retval`和`pthread_join`一样，都是指向返回值的指针。

3. **分离线程**：

   方法：`int pthread_detach(pthread_t tid);`

   - 这个方法主线程、子线程都可以调用。
     - 主线程中调用`pthread_detach(tid)`。
     - 子线程中调用`pthread_detach(pthread_self())`。调用后和主线程分离，子线程结束时自己立即回收资源。
   - 参数`tid`和`pthread_join`方法的`tid`一样，都是创建线程时通过通知得到的`tid`值，表示线程的`id`。

**follow-up：线程崩溃会影响进程吗？**

- 线程没有独立的地址空间，如果崩溃，会发信号。
- 如果没有错误处理的`handler`，操作系统一般直接杀死进程。
- 就算是有`handler`处理，一般也会导致程序崩溃。
- 因为很有可能其他线程或者进程的数据被破坏了。



#### 5. 进程间通信方式

1. **无名管道（pipe）**

   - 无名管道只能用于父子进程或兄弟进程之间、或具有亲缘关系的进程间的通信。
   - 无名管道只能由一端向另一端发送数据，是一种半双工的通信方式。如果通信双方需要同时收发数据，就需要两个无名管道。
   - 相关接口：`inf pipe(int fd[2]);`
     - `fd[2]`：管道两端用`fd[0]`和`fd[1]`来描述，读的一端用`fd[0]`表示，写的一端用`fd[1]`来表示。
     - 通信双方的进程中，写数据的一方需要先把`fd[0]`给`close`掉，读数据的一方需要先把`fd[1]`给`close`掉。

   ![img](https://camo.githubusercontent.com/af6ac5de61c835b0fe14c799c244632fa04239ef2ca9421eee543392353297c8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35336364396164652d623061362d343339392d623464652d3766316662643036636466622e706e67)

2. **有名管道（FIFO）**

   - 有名管道可以在不具有亲缘关系的进程间通信。
   - 相关接口：`int mkfifo(const char *pathname, mode_t mode);`
     - `pathname`：即将创建的`FIFO`文件的路径，如果文件存在需要先删除。
     - `mode`：和`open()`系统调用的参数意义相同。

3. **消息队列（MQ）**

   - 消息队列是消息的链表，存放在内核中并由消息队列标识符标识。
   - 消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。
   - 每个数据块都被认为含有一个类型，接收进程可以独立地接收不同类型的数据块。
   - 消息队列可以独立于读写进程存在，从而避免了`FIFO`（有名管道）中同步管道的打开和关闭时可能产生的困难。
   - 读进程可以根据消息类型有选择地接收消息。而`FIFO`（有名管道）中读进程只能默认接收消息。

4. **共享内存  / 共享存储（shared memory）**

   - 多个进程共享一个给定的存储区。
   - 由于数据不需要在进程之间父子，因此这是最快的一种`IPC`。
   - 进程可以将同一段共享内存连接到它们自己的地址空间。
   - 所有进程都可以访问共享内存中的地址。如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。（需要使用信号量来同步对共享内存的访问）
     - 共享内存的方式有点像多线程中对全局变量的访问，所有进程都可以去修改这块内存的值。
     - 这就导致了在多进程并发的情况下，最终结果是不可预期的。
     - 所以对这块临界区的访问需要通过信号量来进行进程同步。
     - 不过共享内存的优势也很明显：共享内存的速度快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。
   - 相关接口：
     - 创建共享内存：`int shmget(key_t key, int size, int flag);`
       - 成功时返回一个和`key`相关的共享内存标识符，失败则返回`-1`。
       - `key`：为共享内存段命名，多个共享同一片内存的进程使用同一个`key`。
       - `size`：共享内存的容量。
       - `flag`：权限标志位。
     - 连接到共享内存地址空间：`void *shmat(int shmid, void *addr, int flag);`
       - 返回值即共享内存的实际地址。
       - `shmid`：`shmget()`返回的标识。
       - `addr`：决定以什么方式连接地址。
       - `flag`：访问模式。
     - 从共享内存分离：`int shmdt(const void *shmaddr);`
       - 调用成功返回`0`，失败返回`-1`。
       - `shmaddr`：是`shmat()`返回的指针，指向共享内存的实际地址。

5. **信号（signal）**

   - 信号是比较复杂的通信方式，用于通知接收进程有某种事情发生。
   - 除了用于进程间通信外，进程还可以给自身发送信号。

6. **信号量（semaphore）**

   - 信号量是一个计数器，用于为多个进程提供对共享数据对象的访问。
   - 相关接口：`int semget(key_t key, int nsems, int semflag);`
     - 创建信号量。创建成功返回信号量标识符，创建失败返回`-1`。
     - `key`：进程的`pid`。
     - `nsems`：创建信号量的个数。
     - `semflag`：指定信号量的读写权限。

   - 互斥量：
     - 如果信号量的取值只能为`0`或`1`，那么就成为了互斥量（`mutex）`。
     - `0`表示临界区已经加锁，`1`表示临界区已解锁。

7. **内存映射（mapped memory）**

   - 内存映射允许任意多个进程间通信。
   - 每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现该`IPC`机制。

8. **套接字（socket）**

   - 与其他`IPC`机制不同的是，套接字可以用于不同机器间的进程通信。

**follow-up：进程同步与进程通信的区别？**

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。



#### 6. 进程状态转换

![img](https://camo.githubusercontent.com/0398c2bace5b1b0695f5a34f6cfedf6e358db565408abc83dd161de71d3bfec8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50726f6365737353746174652e706e67)

- **就绪状态（ready）**：等待被调度上`CPU`运行。
- **运行状态（running）**
- **阻塞状态（waiting）**：等待（除`CPU`外的）资源 / 事件。
- 只有就绪态和运行态可以相互转换（**面试讲到这里可以去说一下进程调度算法**），其它的都是单向转换。就绪状态的进程通过调度算法从而获得`CPU`时间，转为运行状态；而运行状态的进程，在分配给它的`CPU`时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括`CPU`时间，缺少`CPU` 时间会从运行态转换为就绪态。



#### 7. 进程调度算法

1. **先来先服务（first come first server, FCFS）**

   - 非抢占式的调度算法，按照请求的顺序进行调度。
   - 有利于长作业，不利于短作业。
   - 因为短作业必须一致等待前面的长作业执行完毕才能执行，而长作业又需要很长的执行时间，造成了短作业等待时间过长。

2. **短作业优先（shortest job first, SJF）**

   - 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。
   - 长作业可能会饥饿，处于一直等待短作业执行完毕的状态。
   - 因为如果一直有短作业到来，那么长作业永远得不到调度。

3. **最短剩余时间优先（shortest remaining time next, SRTN）**

   - 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。
   - 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。
   - 如果新的进程需要的时间更少，则挂起当前进程，运行新的进程，否则新的进程等待。

4. **时间片轮转**

   - 将所有就绪进程按照先来先服务的原则排成一个队列。
   - 每次调度时，把`CPU`时间分配给队首进程，该进程可以执行一个时间片。
   - 当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将该进程送到就绪队列的末尾，同时继续把`CPU`时间分配给队首的进程。
   - 时间片轮转算法的效率和时间片的大小有很大关系：
     - 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换地太频繁，在进程切换上就会花过多时间。
     - 而如果时间片过长，那么实时性就不能得到保证。

5. **优先级调度**

   - 为每个进程分配一个优先级，按优先级进行调度。
   - 为了防止低优先级的进程永远得不到调度，可以随着时间的推移增加等待进程的优先级。

6. **多级反馈队列**

   - 多级队列是为需要连续执行多个时间片的进程考虑。
   - 设置多个队列，每个队列时间片大小都不同例如 `1`，`2`，`4`，`8`，...。
   - 进程在第一个队列没执行完，就会被移到下一个队列。
   - 每个队列的优先权也不同，最上面的优先权最高。
   - 只有上一个队列没有进程在排队，才能调度当前队列上的进程。
   - 可以将多级反馈队列这种进程调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

   ![img](https://camo.githubusercontent.com/c20fd7a3268ebc4ef0bce390344de2c5358392ecef2413d849c3095e21047980/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67)

   

#### 8. 进程同步

1. **临界区**

   对临界资源进行访问的**代码**称为临界区。

   为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

   ```C++
   // entry section
   // critical section;
   // exit section
   ```

2. **同步与互斥**

   - **同步**：多个进程之间因为合作而产生的直接制约关系，使得进程之间有一定的先后执行关系。
   - **互斥**：多个进程在同一时刻只有一个进程能够进入临界区。

3. **信号量**

   **信号量（Semaphore）是一个整型变量。**可以对其执行`down`和`up`操作，也就是常见的`P`和`V`操作。

   - **down**：如果信号量大于`0`，执行`-1`操作；如果信号量等于`0`，进程睡眠，等待信号量大于`0`；
   - **up**：对信号量执行`+1`操作，唤醒睡眠的进程让其完成`down`操作。

   `down`和`up`操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

   如果信号量的取值只能为`0`或`1`，那么就成为了**互斥量（Mutex）**。

   - `0`表示临界区已经加锁。
   - `1`表示临界区解锁。

   ```C++
   typedef int semaphore;
   semaphore mutex = 1;
   
   void P1() {
   	down(&mutex);
   	// 临界区
   	up(&mutex);
   }
   
   void P2() {
   	down(&mutex);
   	// 临界区
   	up(&mutex);
   }
   ```

4. **管程**

   - 使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。
   - `C`语言不支持管程，下面的示例代码使用类`Pascal`语言来描述管程。示例代码的管程提供了`insert()`和`remove()`方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。

   ```Pascal
   monitor ProducerConsumer
       integer i;
       condition c;
   
       procedure insert();
       begin
           // ...
       end;
   
       procedure remove();
       begin
           // ...
       end;
   end monitor;
   ```

   - 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其他进程永远不能使用管程。
   - 管程引入了**条件变量**以及相关的操作：`wait()`和`signal()`来实现同步操作。
     - 对条件变量执行`wait()`操作会导致调用进程阻塞，把管程让出来给另一个进程持有。
     - `signal()`操作用于唤醒被阻塞的进程。

**follow-up：生产者-消费者问题**

> **问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品。只有缓冲区不为空，消费者才可以拿走物品。**

1. **使用信号量解决**：

   - 因为缓冲区属于临界资源，因此需要使用一个**互斥量**来控制对缓冲区的互斥访问。
   - 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用**信号量**来统计。
     - 这里需要两个信号量：`empty`记录空缓冲区的数量，`full`记录满缓冲区的数量。
     - `empty`信号量是在生产者进程中使用的，当`empty`不为`0`时，生产者才可以放入物品。
     - `full`信号量是在消费者进程中使用的，当`full`信号量不为`0`时，消费者才可以取走物品。
   - **注意**：不能先对缓冲区加锁，再测试信号量。
     - 也就是说，不能先执行`down(mutex)`，再执行`down(empty)`。
     - 如果这么做了，可能会出现这种情况：生产者对临界区加锁后，执行`down(empty)`操作，发现`empty = 0`，此时生产者睡眠。
     - 而因为生产者对临界区加锁了，消费者不能进入临界区，消费者就无法执行`up(empty)`操作，因此`empty`将永远为`0`，导致生产者永远等待下去，不会释放锁，消费者也因此会永远等待下去。

   ```C++
   #define N 100
   typedef int semaphore;
   semaphore mutex = 1;
   semaphore empty = N;
   semaphore full = 0;
   
   void producer() {
       while(TRUE) {
           int item = produce_item();
           down(&empty);     
           down(&mutex);       // 对临界区加锁总是在信号量之后的
           insert_item(item);
           up(&mutex);
           up(&full);
       }
   }
   
   void consumer() {
       while(TRUE) {
           down(&full);
           down(&mutex);            // 对临界区加锁总是在信号量之后的
           int item = remove_item();
           consume_item(item);
           up(&mutex);
           up(&empty);
       }
   }
   ```

2. **使用管程解决**：

   ```Pascal
   // 管程
   monitor ProducerConsumer
       condition full, empty;
       integer count := 0;
       condition c;
   
       procedure insert(item: integer);
       begin
           if count = N then wait(full);
           insert_item(item);
           count := count + 1;
           if count = 1 then signal(empty);
       end;
   
       function remove: integer;
       begin
           if count = 0 then wait(empty);
           remove = remove_item;
           count := count - 1;
           if count = N -1 then signal(full);
       end;
   end monitor;
   
   // 生产者客户端
   procedure producer
   begin
       while true do
       begin
           item = produce_item;
           ProducerConsumer.insert(item);
       end
   end;
   
   // 消费者客户端
   procedure consumer
   begin
       while true do
       begin
           item = ProducerConsumer.remove;
           consume_item(item);
       end
   end;
   ```

**follow-up：哲学家就餐问题**

1. **问题描述**

   ![img](https://camo.githubusercontent.com/7f8eb6362323b56a5dd8ec061d7ea0c5b0d07a842132598bbed860a8bb941317/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61393037376630362d373538342d346632622d386332302d3361386534363932383832302e6a7067)

   - 五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己**左右两边的两根筷子**，并且**一次只能拿起一根筷子**。

2. **一种错误解法**

   - 错误解法：所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其他哲学家吃完并释放自己手中的筷子，导致死锁。

     ```C++
     #define N 5
     
     void philosopher(int i) {
         while(TRUE) {
             think();
             take(i);             // 拿起左边的筷子
             take((i+1)%N);       // 拿起右边的筷子
             eat();
             put(i);
             put((i+1)%N);
         }
     }
     ```

3. **正确解法（防止死锁发生，设置两个条件）**

   为了防止死锁的发生：可以设置两个条件：

   - 必须同时拿起左右两根筷子（不然就别拿）。
   - 只有在两个邻居都没有进餐的情况下才允许进餐。

   ```C++
   #define N 5
   #define LEFT (i + N - 1) % N      // 左邻居
   #define RIGHT (i + 1) % N         // 右邻居
   #define THINKING 0
   #define HUNGRY   1
   #define EATING   2
   typedef int semaphore;
   int state[N];                // 跟踪每个哲学家的状态
   semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
   semaphore s[N];              // 每个哲学家一个信号量
   
   void philosopher(int i) {
       while(TRUE) {
           think(i);
           take_two(i);
           eat(i);
           put_two(i);
       }
   }
   
   void take_two(int i) {
       down(&mutex);
       state[i] = HUNGRY;
       check(i);
       up(&mutex);
       down(&s[i]);            // 只有收到通知之后才可以开始吃，否则会一直等下去
   }
   
   void put_two(i) {
       down(&mutex);
       state[i] = THINKING;
       check(LEFT);           // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
       check(RIGHT);
       up(&mutex);
   }
   
   void eat(int i) {
       down(&mutex);
       state[i] = EATING;
       up(&mutex);
   }
   
   // 检查两个邻居是否都没有用餐，如果是的话，就 up(&s[i])，使得 down(&s[i]) 能够得到通知并继续执行
   void check(i) {         
       if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
           state[i] = EATING;
           up(&s[i]);
       }
   }
   ```

**follow-up：读者-写者问题**

1. **问题描述**

   允许多个进程同时对数据进行读操作，但不允许读和写以及写和写操作同时发生。

2. **解法**

   一个整型变量`count`记录在对数据进行读操作的进程数量，一个互斥量`count_mutex`用于对`count`加锁，一个互斥量`data_mutex`用于对读写的数据加锁。

   ```C++
   typedef int semaphore;
   semaphore count_mutex = 1;
   semaphore data_mutex = 1;
   int count = 0;
   
   void reader() {
       while(TRUE) {
           down(&count_mutex);
           count++;
           if(count == 1) down(&data_mutex);    // 第一个读者需要对数据进行加锁，防止写进程访问
           up(&count_mutex);
           read();
           down(&count_mutex);
           count--;
           if(count == 0) up(&data_mutex);     // 最后一个读者释放锁，允许写进程访问
           up(&count_mutex);
       }
   }
   
   void writer() {
       while(TRUE) {
           down(&data_mutex);
           write();
           up(&data_mutex);
       }
   }
   ```



#### 9. 僵尸进程、孤儿进程

- **僵尸进程**
  - **如果子进程先退出，父进程还没退出**，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。
  - **设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。**这些信息至少包括进程`ID`，进程的终止状态，以及该进程使用的`CPU`时间，所以当终止子进程的父进程调用`wait`或`waitpid`的时候就可以得到这些信息。
  - 如果一个进程终止，而该进程的所有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程`ID`将被重置为`1`（`init`进程）。
  - 继承这些子进程的`init`进程将清理它们。也就是说，`init`进程将`wait`它们，从而去除它们的僵尸状态。
- **孤儿进程**
  - **如果父进程先退出，子进程还没退出**，那么子进程的父进程将变为`init`进程。（注：任何一个进程都必须有父进程）。
  - 一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。
  - 孤儿进程将被进程号为`1`的`init`进程所收养，并由`init`进程对它们完成状态收集工作。

**follow-up：守护进程**

- 守护进程指**在后台运行的、没有控制终端与之相连的进程**。
  - 守护进程独立于控制终端，周期性地执行某种任务。
  - `Linux`的大多数服务器就是用守护进程的方式实现的，如`Web`服务器进程`http`等。
- 创建守护进程要点：
  1. **让程序在后台运行。**方法是调用`fork()`产生一个子进程，然后使父进程退出。
  2. **调用`setsid()`创建一个新会话期。**控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响。方法是调用`setsid()`使进程称为一个会话组长。`setsid()`调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。
  3. **禁止进程重新打开控制终端。**经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过`fork()`创建新的子进程，使调用`fork()`的进程退出。
  4. **关闭不再需要的文件描述符。**子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。
     - 做法：首先获得最高文件描述符值，然后用一个循环程序，关闭从`0`到最高文件描述符值的所有文件描述符。
  5. **将当前目录更改为根目录。**
  6. **子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为了防止这一点，可以使用`unmask(0)`将屏蔽字清零。**
  7. **处理`SIGCHLD`信号。**
     - 对于服务器进程，在请求到来时往往生成子进程处理请求。
     - 如果子进程等待父进程捕获状态，则子进程将成为僵尸进程，从而占用系统资源。
     - 如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。
     - 在`Linux`下可以简单地将`SIGCHLD`信号的操作设为`SIG_IGN`。这样，子进程结束时不会产生僵尸进程。



#### 10. 中断、异常

1. **（外）中断**
   - 由`CPU`执行指令以外的事件引起。
   - 如`I/O`完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。
   - 此外还有时钟中断、控制台中断等。
2. **异常**
   - 由`CPU`执行指令的内部事件硬件引起。
   - 如非法操作码、地址越界、算术溢出等。

**follow-up：陷入**

- **陷入（`trap`）指的是在用户程序中使用系统调用，从用户态陷入到内核态。**



#### 11. 硬中断、软中断

> **从本质上来讲，中断是一种电信号。**
>
> **当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。**
>
> **如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是停止自己正在做的事，跳到中断处理程序的入口点，进行中断处理。**

1. **硬中断**
   - 我们通常所说的中断指的是**硬中断（hardirq）**。
   - 硬中断是由于系统相连的外设（比如网卡、硬盘）自动产生的。
   - 硬中断主要是用来通知操作系统外设状态的变化。
   - 比如当网卡收到数据包的时候，就会发出一个中断。
2. **软中断**
   - 为了满足实时系统的要求，中断处理应该是越快越好。
   - `Linux`为了实现这个特点，当中断发生的时候，**硬中断处理那些短时间就可以完成的工作。**
   - **而那些处理事件比较长的工作，放到中断之后来完成，也就是软中断（`softirq`）来完成。**
   - **软中断指令**
     - `int`是软中断指令。
     - 中断向量表是中断号和中断处理函数地址的对应表。
     - 例：`int n`——触发软中断`n`。相应的中断处理函数的地址为：**中断向量表地址 + 4 * n**。
3. **硬中断与软中断的区别**
   1. 硬中断是由外设引发的。软中断是执行中断指令产生的。
   2. 硬中断的中断号是由中断控制器提供的。软中断的中断号是由指令直接指出的，无需使用中断控制器。
   3. 硬中断可屏蔽。软中断不可屏蔽。
   4. 处理时间不同。
      - 硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长的时间，称为上半部。
      - 软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。

**follow-up：中断嵌套**

- `Linux`下硬中断是可以嵌套的。但是没有优先级的概念。也就是说，任何一个新的中断都可以打断正在执行的中断（但同种中断除外）。
- 软中断不能嵌套，但相同类型的软中断可以在不同`CPU`上并行执行。



#### 12. 内核态、用户态、系统调用、宏内核、微内核

1. **内核态、用户态**

   操作系统需要两种`CPU`状态：

   - 内核态（`Kernel Mode`）：运行操作系统程序。
   - 用户态（`User Mode`）：运行用户程序。

   **特权指令、非特权指令**

   - 特权指令：只能由操作系统使用、用户程序不能使用的指令。
     - 启动`I/O`、内存清零、修改程序状态字、设置时钟、允许 / 禁止中断、停机。
   - 非特权指令：用户程序可以使用的指令。
     - 控制转移、算术运算、访管指令（陷入指令）、取数指令。

2. **系统调用**

   - 系统调用是在用户编程时可以调用的操作系统功能。

   - 系统调用是操作系统提供给编程人员的唯一接口。

   - 系统调用会使`CPU`状态从用户态陷入内核态。

   - 典型系统调用举例

     - 每个操作系统都提供几百种系统调用，涉及到**进程控制、进程通信、文件使用、目录操作、设备管理、信息维护等**。

   - **系统调用机制的设计**：

     1. 中断 / 异常机制
        - 支持系统调用服务的实现。
     2. 选择一条特殊指令：陷入指令（亦称访管指令）
        - 引发异常，完成用户态到内核态的切换。
     3. 系统调用号和参数
        - 每个系统调用都首先给定一个编号（功能号）。
     4. 系统调用表
        - 存放系统调用服务例程的入口地址。

   - **系统调用的执行过程**：

     当`CPU`执行到特殊的陷入指令时：

     1. **中断 / 异常机制**：硬件保护现场。通过查中断向量表把控制权转给系统调用总入口程序。
     2. **系统调用总入口程序**：保存现场，将参数保存在内核堆栈里。通过查系统调用表把控制权转给相应的系统调用例程或内核函数。
     3. **执行系统调用例程**。
     4. **恢复现场，返回用户程序**。

3. **宏内核**

   - 宏内核是将操作系统功能作为一个紧密结合的整体放到内核。
     - 由于各模块共享信息，因此有很高的性能。

4. **微内核**

   - 由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。

   - 移出的部分根据分层的原则划分成若干服务，相互独立。

   - 在微内核结构下，操作系统被划分成小的、定义良好的模块。**只有微内核这一个模块运行在内核态，其余模块运行在用户态。**

   - 因为需要频繁地在用户态和内核态之间进行切换，所以会有一定的性能损失。

     ![img](https://camo.githubusercontent.com/e244b7965823da98c230d7b71038b8ee11dcb2e30b5e8fb1272dcd76008a889f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f325f31345f6d6963726f6b65726e656c4172636869746563747572652e6a7067)



#### 13. 死锁必要条件

1. **互斥**：每个资源要么已经分配给了一个进程，要么就是可用的。
2. **占有和等待**：已经得到了某个资源的进程可以再请求新的资源。
3. **不可抢占**：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
4. **环路等待**：有两个或两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。



#### 14. 死锁处理方法

> **死锁主要有四种处理方法：**
>
> - **鸵鸟策略**
> - **死锁检测与死锁恢复**
> - **死锁预防**
> - **死锁避免**

##### 鸵鸟策略

- 把头埋在沙子里，假装根本没发生问题。
- 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任何措施的方法会获得很高的性能。
- 当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。
- 大多数操作系统，包括`Unix`、`Linux`和`Windows`，处理死锁的办法仅仅是忽略它。

##### 死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

1. 每种类型一个资源的死锁检测

   ![img](https://camo.githubusercontent.com/5663be4d3b58da1b738412ca4854b61d255974230c1c88875f96511618a5bae0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62316661303435332d613462302d346561652d613335322d3438616363613866666637342e706e67)

   - 上图为资源分配图，其中方框表示资源，圆圈表示进程。
   - 资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。
   - 图`a`可以抽取出环，如图`b`，它满足了环路等待条件，因此会发生死锁。
   - **每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。**

2. 每种类型多个资源的死锁检测

   ![img](https://camo.githubusercontent.com/65aa9be0a5faea5fb50ec17101ce3e900688ad9079ac67fed8bb7fb40c8578f1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65316564613364352d356563382d343730382d386532352d3161303463356531316634382e706e67)

   上图中，有三个进程四个资源，每个数据代表的含义如下：

   - `E`向量：资源总量。
   - `A`向量：资源剩余量。
   - `C`矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量。
   - `R`矩阵：每个进程请求的资源数量。

   死锁检测：

   - 进程`P1`和`P2`所请求的资源都得不到满足，只有进程`P3`可以。
   - 让`P3`执行，之后释放`P3`拥有的资源，此时`A = (2 2 2 0)`。
   - `P2`可以执行，执行后释放`P2`拥有的资源，`A = (4 2 2 1)` 。
   - `P1`也可以执行。所有进程都可以顺利执行，没有死锁。

   算法总结如下：

   - 每个进程最开始时都不被标记，执行过程有可能被标记。
   - 当算法结束时，任何没有被标记的进程都是死锁进程。
   - 算法过程：
     1. 寻找一个没有标记的进程`Pi`，它所请求的资源小于等于`A`。
     2. 如果找到了这样一个进程，那么将`C`矩阵的第`i`行向量加到`A`中，标记该进程，并转回 `1`。
     3. 如果没有这样一个进程，算法终止。
     4. 死锁恢复（在死锁检测之后）
        - 利用抢占恢复
        - 利用回滚恢复
        - 通过杀死进程恢复


##### 死锁预防

> **死锁预防是在程序运行之前预防死锁的发生。**

1. **破坏互斥条件**

   - 如果资源不被一个进程所独占，那么死锁肯定不会发生。
   - 例如，假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。由于守护进程不会请求别的资源，因此不会因打印机而产生死锁。

2. **破坏占有和等待条件**

   - 禁止已持有资源的进程再等待其他资源。
   - 一种实现方式是**规定所有进程在开始执行前请求所需要的全部资源。**例如，哲学家就餐问题中，要求哲学家同时拿起左右的两根筷子才可以吃。
   - 另一种破坏占有和等待的方案是，要求**当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需的全部资源**。

3. **破坏不可抢占条件**

4. **破坏环路等待条件**

   两种方法。

   1. 一种是保证每一个进程在任何时刻只能占用一个资源，如果要请求另外一个资源，它必须先释放第一个资源。
      - 但假如进程正在把一个大文件从磁带机上读入并送到打印机打印，那这种限制是不可接受的。
   2. 另一种方法是给资源统一编号，进程只能按编号顺序来请求资源。
      - 尽管对资源编号的方法消除了死锁的问题，但**几乎找不到一种使每个人都满意的编号次序**。
      - 当资源包括进程表项、假脱机磁盘空间、加锁的数据库记录以及其他抽象资源时，潜在的资源及各种不同用途的资源数目会变得很大，以至于编号方法根本无法使用。

##### 死锁避免（安全状态、银行家算法）

> **死锁避免是在程序运行时避免发生死锁。**

1. **安全状态**

   - 定义：**如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序使得每一个进程都可以运行完毕，则称该状态是安全的**。

   - **安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。**银行家算法与死锁检测算法非常类似，可以结合着做参考对比。=

   - 例子：

     ![img](https://camo.githubusercontent.com/09589c4bfe0e5514a44fc74cd63069f018b03246880e1f89b887313bbbdf2073/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65643532333035312d363038662d346333662d623334332d3338336532643139343437302e706e67)

     - 图`a`的第二列`Has`表示已拥有的资源数，第三列`Max`表示总共需要的资源数，`Free`表示还有可以使用的资源数。
     - 从图`a`开始出发，先让`B`拥有所需的所有资源（图`b`），运行结束后释放`B`。
     - 此时`Free` 变为`5`（图`c`），接着以同样的方式运行`C`和`A`，使得所有进程都能成功运行，因此可以称图`a`所示的状态时安全的。

2. **单个资源的银行家算法**

   - 一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度。

   - 算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求。

   - 否则予以分配。

     ![img](https://camo.githubusercontent.com/381663ffc7a4db80478e5f454a11400debf6c13628632e3396fdaa7a6e555716/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64313630656332652d636665322d343634302d626461372d3632663533653538623863302e706e67)

     - 上图`c`为不安全状态，因此算法会拒绝之前的请求，从而避免进入图`c`中的状态。

3. **多个资源的银行家算法**

   [![img](https://camo.githubusercontent.com/5334ac030b7446b89615c4319275fe27330481ac6f1a9280fc682f6dffcf5241/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36326530646434662d343463332d343365652d626236652d6665646239653036383531392e706e67)](https://camo.githubusercontent.com/5334ac030b7446b89615c4319275fe27330481ac6f1a9280fc682f6dffcf5241/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36326530646434662d343463332d343365652d626236652d6665646239653036383531392e706e67)

   - 上图中有五个进程，四个资源。
   - 左边的图表示已经分配的资源，右边的图表示还需要分配的资源。
   - 最右边的`E`、`P`以及`A`分别表示：总资源、已分配资源以及可用资源。
   - 注意这三个为向量，而不是具体数值。例如`A=(1020)`，表示`4`个资源分别还剩下`1/0/2/0`。

   **检查一个状态是否安全的算法如下**：

   1. 查找右边的矩阵是否存在一行小于等于向量`A`。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
   2. 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到`A`中。
   3. 重复以上两步，直到所有进程都标记为终止，则状态是安全的。

   **如果一个状态不是安全的，需要拒绝进入这个状态。**



#### 15. 虚拟内存、地址映射

##### 虚拟内存

> **虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。**

1. **虚拟内存解决了什么问题？**

   - 需要运行的程序往往大到内存无法容纳，另外操作系统还需要支持多个程序同时运行。
   - 即使内存可以满足其中单独一个程序的需要，总体来看它们仍然超出了内存大小。

2. **虚拟内存的基本思想**

   - 每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页或页面（`page`）。
   - 每一页有连续的地址范围。
   - 这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。
   - 当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。

3. **虚拟内存的意义**

   - 虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存。
   - 也就是说，一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。
   - 例如，有一台计算机可以产生`16`位地址，那么一个程序的地址空间范围是`0~64K`。该计算机只有`32KB`的物理内存，虚拟内存技术允许该计算机运行一个`64K`大小的程序。

   ![img](https://camo.githubusercontent.com/01251b0ef66ccf744889c26424634aae680922be7d993522b4d831dca3c9511c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37623238316231652d303539352d343032622d616533352d3863393130383463333363312e706e67)

##### 逻辑地址转换为物理地址的过程（地址映射）

- 可以借助进程的页表将逻辑地址转换为物理地址。

- 通常会在系统中设置一个页表寄存器(`PTR`)，存放页表在内存中的起始地址`F`和页表长度`M`。

- 进程未执行时，页表的始址和页

- 注意:页面大小是2的整数幂。

- 设页面大小为`L`，逻辑地址`A`到物理地址`E`的变换过程如下：

  ![image-20210407164634150](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407164634150.png)

  - 例：若页面大小`L`为`1K`字节，页号`2`对应的内存块号`b=8`，将逻辑地址`A=2500`转换为物理地址`E`。

    - 等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占`10`位(说明一个页面的大小为`2^10B = 1KB`)，页号`2`对应的内存块号`b=8`，将逻辑地址`A=2500`转换为物理地址`E`。

    > ① 计算页号、页内偏移量
    >
    > - 页号`P = A / L = 2500 / 1024 = 2`。
    > - 页内偏移量`W= A % L = 2500 % 1024 = 452`。
    >
    > ② 根据题中条件可知，页号`2`没有越界，其存放的内存块号`b=8`。
    >
    > ③ 物理地址`E=b*L+W=8 * 1024+ 425 = 8644`。
    >
    > - 在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。
    > - 因此，页式管理中地址是一维的。
    > - 即，**只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分**，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。

**follow-up：内存覆盖、内存交换**

1. **内存覆盖**：
   - 由于程序运行时，并非任何时候都要访问程序及数据的各个部分（尤其是大程序）。
   - 因此可以把用户空间分为一个固定区和若干个覆盖区。
   - 将经常活跃的部分放在固定区，其余部分按照调用关系分段。
   - 首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。
   - **覆盖技术的特点**：打破了必须将一个进程的全部信息装入内存后才能运行的限制，但同时运行的程序的代码量大于主存时仍不能运行。
     - 另外，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。
2. **内存交换**：
   - **交换（对换）技术的设计思想**：内存空间紧张时，系统将内存中的某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（这个过程就是进程在内存与磁盘间的调度）。
   - **换入**：把准备好竞争`CPU`运行的程序从辅存移到内存。
   - **换出**：把处于等待状态（或`CPU`调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来。
   - **什么时候会进行内存的交换？**
     - 内存交换通常在许多进程运行且内存吃紧时进行，而在系统负荷降低时就暂停。
     - 例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程。如果缺页率明显下降，就可以暂停换出。



#### 16. 页面置换算法

> - **在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断，从而将该页调入内存中。**
> - **此时，如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。**
> - **页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。**
>   - **在缓存系统中，缓存的大小有限。**
>   - **当有新的缓存到达时，需要淘汰一部分已经存在的缓存。这样才有空间存放新的缓存数据。**

- **页面置换算法的主要目标是**：使页面置换频率最低（也可以说缺页率最低）。

常见的页面置换算法有：

1. **最佳 页面置换算法（OPT, Optimal replacement algorithm）**

   - 所选择的被换出的页面将是最长时间内不再被访问的页面。

   - 这个算法可以保证获得最低的缺页率。

   - 不过这个算法是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

   - 举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：

     `7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1`

     - 开始运行时，先将`7, 0, 1`三个页面装入内存。
     - 当进程要访问页面`2`时，产生缺页中断，会将页面`7`换出，因为页面`7`再次被访问的时间最长。
     
     ![图片](https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbX8vl1W1KvabHnn3GLYPvanwSdsoFrrPyAB6cCmNCmqjPb2fsB8gBA5p9saFEOsTaicGQaswHeho2ibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

2. **最近最久未使用 页面置换算法（LRU, Least Recently Used）**

   - 虽然我们无法知道将来要使用的页面的情况，但是可以知道过去使用页面的情况。

   - `LRU`算法将最近最久未使用的页面换出。

   - 为了实现`LRU`，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的（`LeetCode 146`）。

     ![图片](https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbX8vl1W1KvabHnn3GLYPvanwx4LYVrJU8eP5JrYLQgS5DK4vqCJCWe6YzF5Zz7RU0KyHFibUQKe0iaqA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

3. **最近未使用 页面置换算法（NRU, Not Recently Used）**

   - 每个页面都有两个状态位：`R`与`M`。
   - 当页面被访问时设置页面的`R = 1`，当页面被修改时设置`M = 1`。
   - 其中`R`位会被定时清零。
   - 可以将页面分成以下四类：
     - 第一类：`R = 0, M = 0`
     - 第二类：`R = 0, M = 1`
     - 第三类：`R = 1, M = 0`
     - 第四类：`R = 1, M = 1`
   - 当发生缺页中断时，`NRU`算法随机地从类编号最小的非空类中挑选一个页面将它换出。
   - **NRU算法的特点**：
     - `NRU`算法优先换出已经被修改的脏页面（比如`R = 0, M = 1`）。
     - 而不是被频繁使用的干净页面（`R = 1, M = 0`）。

4. **先进先出 页面置换算法（FIFO, First In First Out）**

   - 选择被换出的页面是最先进入的页面。

   - 该算法会将那些经常被访问的页面换出，导致缺页率升高。

     ![图片](https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbX8vl1W1KvabHnn3GLYPvanw5ib6AQQAHywicQRDzmUBdapN4a50tCSo2KFX2oU80nwH466lciaBNOibzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

     ![图片](https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbX8vl1W1KvabHnn3GLYPvanwkOZckssVV0bOJibHPLQMnicm6EOObicCgIvlmD7Tpomvlias9ODWEpbt1w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

5. **第二次机会  页面置换算法**

   `FIFO`算法可能会把经常使用的页面置换出去。为了避免这个问题，对`FIFO`算法做一个简单的修改：

   - 当页面被访问（读或写）时设置该页面的`R`位为`1`。

   - 需要替换页面的时候，检查最老页面的`R`位。

     - 如果`R`位是`0`，那么这个页面既老又没有被使用，可以立即将该页面置换掉。
     - 如果`R`位是`1`，就将`R`位清零，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样（没有将该页面置换出去，也就是，给了第二次机会），然后继续从链表的头部开始搜索（寻找`R`位为`0`的页面置换出去）。

     ![img](https://camo.githubusercontent.com/579e409ef1551a1dc1c59487bc2fd54e93129ec97573721a3027376aa7f17595/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65636638616435642d353430332d343862392d623665372d6632653230666665386663612e706e67)

6. **时钟 页面置换算法（Clock）**

   第二次机会算法需要在链表中移动页面，降低了效率。

   - 时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

     ![img](https://camo.githubusercontent.com/66bf1e33e909443e7fd77bf1d37c6144162b0545ac0aa6b078928e40a4d64878/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35663565663062362d393865612d343937632d613030372d6636633535323838656162312e706e67)
     
     ![图片](https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbX8vl1W1KvabHnn3GLYPvanwcDh1EfNicsSaUymezeERoTdujDpw6tYX7D4IbayVfDs3h0Am6QXWzhg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



#### 17. 分页

>  **需要运行的程序往往大到内存无法容纳，而且必须需要系统能够支持多个程序同时运行，即使内存可以满足其中单独一个程序的需要，总体来看它们仍然超出了内存大小。**

- 由程序产生的地址称为**虚拟地址（virtual address）**，它们构成了一个虚拟地址空间（`virtual address space`）。

- 在没有虚拟内存的计算机上，系统直接将虚拟内存送到内存总线上，读写操作使用具有同样地址的物理内存字。

- 而在使用虚拟内存的情况下，虚拟内存不是被直接送到内存总线上，而是被送到**内存管理单元（Memory Management Unit, MMU）**，**MMU把虚拟地址映射为物理内存地址。**

- 内存管理单元（`MMU`）管理着程序地址空间和物理内存的转换，其中的**页表（`Page Table`）存储着页（程序地址空间）和页框（物理内存空间）的映射表。**

- 一个虚拟地址分成两个部分：一部分存储页面号，一部分存储偏移量。

- 例：下图的页表存放着`16`个页，这`16`个页需要用`4`个比特位来进行索引定位。

  - 例如，对于虚拟地址`0010 0000 0000 0100`。

  - 前`4`位存储页面号`2`，读取表项内容为`110 1`。页表项的最后一位表示页面是否存在于内存中，`1`表示存在，`0`表示不存在。

  - 后`12`位存储偏移量。

  - 因此，这个页对应的页框的地址为：`110 0000 0000 0100`。（前三位是从页表项获得的，后12位是偏移量）。

    ![img](https://camo.githubusercontent.com/1f3a60c6aaac33dd000b9d6a39069d3ddaf2bb04c22b8bcda782eca707eb64fe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63663433383661312d353863392d346563612d613137662d6531326231653937373065622e706e67)



#### 18. 分段

虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。

**What's wrong with 分页？**

下图为一个编译器在编译过程中建立的多个表。有`4`个表是动态增长的。

- 如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。

  ![img](https://camo.githubusercontent.com/bc968c738c37aa7ad6d63d9b95a4803f11fe14aac87f571558024d19af30d399/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32326465303533382d376336652d343336352d626433622d3863653363353930303231362e706e67)

- **分段的做法是把每个表分成段，一个段构成一个独立的地址空间。**

- **每个段的长度可以不同，并且可以动态增长。**

  ![img](https://camo.githubusercontent.com/836f0a92a1f8ff0dee7112c8fc213daa419a42e82cd543d6fd87100fc2624bec/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65303930306262322d323230612d343362372d396161392d3164356364353566663536652e706e67)



#### 19. 分页与分段的比较

1. **对程序员的透明性**：
   - 分页透明。
   - 分段需要程序员显式划分每个段。
2. **地址空间的维度**：
   - 分页是一维地址空间。
   - 分段是二维的。
3. **大小是否可以改变**：
   - 页的大小不可变。
   - 段的大小可以动态改变。
4. **出现的原因**：
   - 分页主要用于实现虚拟内存，从而获得更大的地址空间。
   - 分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。



#### 20. 段页式

- 程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页
- 这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。



#### 21. 设备管理、磁盘结构、磁盘调度算法

**磁盘结构**

- 盘面（`Platter`）：一个磁盘有多个盘面。

- 磁道（`Track`）：盘面上的圆形带状区域，一个盘面可以有多个磁道。

- 扇区（`Track Sector`）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有`512 bytes`与`4K`两种大小。

- 磁头（`Head`）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）。

- 制动手臂（`Actuator arm`）：用于在磁道之间移动磁头。

- 主轴（`Spindle`）：使整个盘面转动。

  ![img](https://camo.githubusercontent.com/062b5e89146b6df61a790e3585635f2d8892ab9f8f6181da26aa58a9cbd55922/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30313466626334642d643837332d346131322d623136302d3836376464616564393830372e6a7067)

**磁盘调度算法**

> **读写一个磁盘块的时间的影响因素有：**
>
> 1. **旋转时间**（主轴转动盘面，使得磁头移动到适当的扇区上）。
> 2. **寻道时间**（制动手臂移动，使得磁头移动到适当的磁道上）。
> 3. **实际的数据传输时间**。
>
> **其中，寻道时间最长。**
>
> **因此，磁盘调度算法的主要目标是使磁盘的平均寻道时间最短。**

1. **先来先服务（FCFS, First Come First Serve）**

   - 按照磁盘请求的顺序进行调度。
   - 优点是：公平和简单。
   - 缺点也很明显：因为未对寻道做任何优化，使平均寻道时间可能较长。

2. **最短寻道时间优先（SSTF, Shortest Seek Time First）**

   - 优先调度与当前磁头所在磁道距离最近的磁道。

   - 虽然平均寻道时间比较低，但是不够公平。

   - 如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，即出现了饥饿现象。

   - 具体来说，两端的磁道请求更容易出现饥饿现象。

     ![img](https://camo.githubusercontent.com/4aaee136900eb1ece1352fa6ca5b92f37e59801a6fcd0a2345afa73ca44fd5b0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34653234383565342d333462642d343936372d396630322d3063303933623739376161612e706e67)

3. **电梯算法（SCAN）**

   - 电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

   - 电梯算法（扫描算法，`SCAN`）和电梯的运行过程类似：

     - 总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

   - 因为考虑了移动方向，因此所有的磁盘请求都会被满足。并解决了`SSTF`（最短寻道时间优先）的饥饿问题。

     ![img](https://camo.githubusercontent.com/e4956eee145c33a868e367fe6a32eb40465503a4e6a31755ca4fe5a4a83d4019/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373163653038662d633132342d343735662d623439302d6265343466656463366432652e706e67)

     

#### 22. 快表（TLB）

> **快表，又称联想寄存器（`TLB`），是一种访问速度比内存快很多的高速缓冲寄存器。**

- 快表用来存放当前访问的若干页表项，以加速地址变换的过程。

- 与之对应，内存中的页表被称为慢表。

  ![image-20210407170952025](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407170952025.png)



#### 23. 局部性原理

局部性原理主要分为时间局部性和空间局部性。

- **时间局部性**：

  - 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行。
  - 如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量循环）。

- **空间局部性**：

  - 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。
  - 因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的。

  ![image-20210407171208445](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407171208445.png)



#### 24. 抖动 / 颠簸现象

- **定义**：刚刚换出内存的页面马上又要换入内存，刚刚换入内存的页面马上又要换出内存，这种频繁的页面调度行为称为抖动，或颠簸。
- **产生抖动的主要原因**：进程频繁访问的页面数目高于可用的物理块数。即，分配给进程的物理块不够。



#### 25. 内部碎片、外部碎片

1. **内部碎片**
   - 分配给某些进程的内存区域有些部分没用上。
   - 内部碎片常见于固定分配方式。
   - 例：内存总量相同，`100M`。
     - **固定分配**：将`100M`分割成`10`块，每块`10M`，一个程序需要`45M`，那么需要分配`5`块，第五块只用了`5M`，剩下的`5M`就是内部碎片。
     - **分段式分配**：按需分配。一个程序需要`45M`，就给分配`45M`，剩下的`55M`供其他程序使用，不存在内部碎片。
2. **外部碎片**
   - 内存中某些空闲区因为比较小，而难以利用上，一般出现在内存动态分配方式中。
   - 例：内存总量`100M`。分段式分配：比如内存分配依次为`5M`，`15M`，`50M`，`25M`，程序运行一段时间之后，`5M`，`15M`的程序运行完毕，释放内存，其他程序还在运行，这时若再次分配一个`10M`的内存供其他程序使用，只能从头开始分配。这样就会存在`10M + 5M`的外部碎片。

**follow-up：如何消除碎片文件？**

- 对于**内部碎片**，可以通过**紧凑技术**解决：
  - 操作系统不时地对进程进行移动和整理。
  - 但是这需要动态重定位寄存器的支持，且相对费时。
  - 紧凑的过程类似于`Windows`系统中的磁盘整理程序，只不过后者是对外存空间的紧凑。
- 解决**外部内存碎片**可以使用**内存交换**：
  - 可以把音乐程序占用的那`256MB`内存写到硬盘上，然后再从硬盘上读回到内存里。
  - 不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的`512MB`内存后面。这样就能空出连续的`256MB`空间，于是新的`200MB`程序就可以装载进来。
  - 回收内存时要尽可能地将相邻的空间空间合并。
