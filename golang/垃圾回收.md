#### 2.1 常见的GC实现方式有哪些？

- 标记-清扫（三色标记）：缺点为有内存碎片

- 标记-压缩

  解决了内存碎片问题，但会破坏缓存局部性，且需要额外空间来标记移动。

- 半空间复制

  空间换时间，保留一般的内存空间用于快速压缩内存。

- 引用计数

  必须原子更新，并发困难。

- 分代GC

  按照存活时间划分，前提是死去的对象一般都是新创建不久。

  不反复扫描旧对象，加快了gc速度和吞吐量，减少stw。

  但没办法及时回收老一代对象，需要额外开销区分新老对象。

#### 2.2 GC的触发

- 阈值：默认内存扩大一倍，启动gc
- 定期：默认2min触发一次gc，src/runtime/proc.go:forcegcperiod
- 手动：runtime.gc()

#### 2.3 STW

stop the world是gc的最大性能问题，对于gc而言，需要停止所有的内存变化，即停止所有的goroutine，等待gc结束之后才恢复。

标记-清除(mark and sweep)算法的STW(stop the world)操作，就是runtime把所有的线程全部冻结掉，所有的线程全部冻结意味着用户逻辑是暂停的。这样所有的对象都不会被修改了，这时候去扫描是绝对安全的。

Go如何减短这个过程呢？标记-清除(mark and sweep)算法包含两部分逻辑：标记和清除。

我们知道Golang三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不碰触黑色对象，只清除白色的对象，肯定不会影响程序逻辑。所以： `清除操作和用户逻辑可以并发。`

标记操作和用户逻辑也是并发的，用户逻辑会时常生成对象或者改变对象的引用，那么标记和用户逻辑如何并发呢？这里就需要写屏障

#### 2.4 GC流程

1. 清扫终止: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC
2. 标记: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收
3. 标记终止: 完成标记工作, 重新扫描部分根对象(要求STW)
4. 清扫: 按标记结果清扫span

目前整个GC流程会进行两次STW(Stop The World), 第一次是**标记阶段**的开始, 第二次是**标记终止**阶段.

- 第一次STW会准备根对象的扫描, 启动写屏障(Write Barrier)和辅助GC(mutator assist).
- 第二次STW会重新扫描部分根对象, 禁用写屏障(Write Barrier)和辅助GC(mutator assist).

需要注意的是, 不是所有根对象的扫描都需要STW, 例如扫描栈上的对象只需要停止拥有该栈的G.
从go 1.9开始, 写屏障的实现使用了Hybrid Write Barrier, 大幅减少了第二次STW的时间.

**混合写屏障**：对正在被覆盖的对象进行着色，且如果当前栈未扫描完成，则同样对指针进行着色

**辅助GC**：辅助GC是在mallocgc中执行一部分gc标记的机制。每分配一定数量的内存，就会在mallocgc中做一些gc标记工作。如果mallocgc分配了过多内存却没有完成足够多的标记工作，就会被挂起，直到其他GC工作线程完成了足够多的工作或GC结束时才会被唤醒。这个机制的目的是防止GC过程中mallocgc执行过快分配过多新内存，导致GC持续时间过长或无法完成。

mallocgc是负责堆分配的关键函数，runtime中的new系列和make系列函数都依赖它。

#### 2.5 写屏障

编译器在赋值操作时，会插入一段代码，来避免扫描遗漏的问题。

因为go支持**并行GC**， GC的扫描和go代码可以同时运行，这样带来的问题是GC扫描的过程中go代码有可能改变了对象的依赖树。

例如开始扫描时发现根对象A和B，B拥有C的指针。

1. GC先扫描A，A放入黑色
2. B把C的指针交给A
3. GC再扫描B，B放入黑色
4. C在白色，会回收；但是A其实引用了C。

为了避免这个问题, go在GC的标记阶段会启用写屏障(Write Barrier).

启用了写屏障(Write Barrier)后，

1. GC先扫描A，A放入黑色
2. B把C的指针交给A
3. **由于A在黑色，所以C放入灰色**
4. C没有子对象，放入黑色
5. 扫描B，B没有子对象，放入黑色

即使A可能会在稍后丢掉C, 那么C就在下一轮回收。

开启写屏障之后，当指针发生改变, GC会认为在这一轮的扫描中这个指针是**存活**的, 所以放入**灰色**。