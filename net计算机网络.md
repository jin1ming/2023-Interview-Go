[TOC]

## 通用

### 浏览器访问一个网站，都经历了怎样一个流程？

1.  **产生http请求**
	请求报文包含请求行（方法、URL、版本）、消息头（字段名、字段值）、消息体
	响应报文包括状态行（版本、状态码、短语）、消息头（字段名、字段值）、消息体
2. **dns查询**
	查询dns缓存和hosts文件->客户端查询本地dns服务器->本地dns服务器查询根域名服务器->根域名服务器返回顶级域名服务器地址->本地dns服务器请求顶级域名服务器->顶级域名服务器返回权威dns服务器->本地dns服务器请求权威dns服务器->本地dns将ip返回给客户端
3. **tcp传输**
	**tcp报文**
	源端口号（16b）、目的端口号（16b）
	序号（32b）、确认序列（32b）
	首部长度（4b）、保留（6b）、状态位（urg、ack、psh、rst、syn、fin）、窗口大小（16b）、校验和（16b）、紧急指针（16b）
	选项、数据
	**三次握手**
	client(close->syn_sent)->SYN->server(listen->syn_rcvd)->SYN+ACK->client(syn_sent->established)->ACK->server(established)
	**分割数据**
	HTTP请求报文超过了MSS时需要分块
	MSS(1460字节) = 1500(MTU) - TCP报头(20) - IP报头(20)
4. **IP**
	**IP报文**
	版本（4b）、首部长度（4b）、服务类型TOS（8b）
	总长度（16b）、标识（16b）
	标志（3b）、片偏移（13b）、TTL（8b）、协议（8b）
	首部校验和（16b）、源IP地址（32b）、目标IP地址（32b）
	选项、数据
5. **MAC与ARP**
	**MAC包头**
	接收方mac地址（48b）、发送方mac地址（48b）、协议类型（16b，IP？ARP？）
6. **其它**
	网卡、交换机、路由器
	
### 网络的457层

应用层、传输层、网络层、数据链路层

应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

应用层、运输层、网络层、数据链路层、物理层

## TCP/UDP

### TCP协议和UDP协议有什么区别？

面向连接&无连接，字节流&数据包，全双工&单播广播，可靠&不可靠

### TCP可靠性指的是什么

从 RFC-793 中定义可知，可靠性指的是从网络 IO 缓冲中读出来的数据必须是无损的、无冗余的、有序的、无间隔的。翻译过来说要保证的可靠性的话，就要解决数据中出现的损坏，乱序，丢包，冗余这四个问题

### TCP的可靠性如何保证

TCP 从三个维度去确保了可靠性，是**「差错控制」「流量控制」「拥塞控制」  **

**差错控制**一定的程度上已经保证了基本的可靠性 

1. 保证数据无损。 TCP 的传输报文段中使用了校验和 checksum，保证本次传输的报文是无损的 	
2. 保证有序和不冗余。在传输报文中使用了 seq 字段去解决乱序及冗余问题 	
3. 保证数据报文们无间隔。在传输报文中使用了 ack 字段，也就是确认应答机制（ACK 延迟确认+累计应答机制） + 超时重传机制（重传机制还细分为快速重传机制（发三个数据包都没有回复））去解决了丢包导致数据出现间隔的问题（流量控制也能够有效的预防丢包的机制之一）。  

**流量控制**（用于接受者）是为了控制发送端不要一味的发送数据导致网络阻塞，和阻止发送方发送的数据不要超过接收方的最大负载，因为超过最大负载会导致接收方丢弃数据而进一步触发超时重传去加重网络阻塞。流量控制的主要手段是通过窗口去做的，每次接受方应答时，都会带一个 window 的字段（三次握手会确定初始的 window 字段），标识了现在接受方能够接受的最大数据量，发送方会根据这个 window 字段发送多个报文直到达到 window 的上限（停等协议的网络传输效率太低），这时应答报文里面的 window 会返回 0，之后发送方会停止发送报文一段时间，然后发送窗口探测的报文去查看接受方是否已经处理好之前发送的数据，更新窗口大小（更新窗口大小的机制也叫做滑动窗口机制）  

**拥塞控制**（用于网络）主要是为了在发生网络拥堵后不进一步触发 TCP 的超时重传进制导致进一步的网络拥堵和网络性能下降。 发送方会自己维护一个拥堵窗口，默认为 1 MSS（最大长度报文段）。控制手段主要有慢启动、拥塞避免、快重传、快恢复。

1. 慢启动。思路是一开始不要传输大量的数据，而是先试探网络中的拥堵程度再去逐渐增加拥塞窗口大小（一般是指数规律增长）。
2. 拥塞避免。拥塞避免思路也和慢启动类似，只是按照线性规律去增加拥堵窗口的大小。 	慢启动和拥塞避免一般会配合使用，有个慢启动阈值，这个阈值取值是可配置的。当小于慢启动阈值时则使用慢启动策略，大于则使用拥塞避免策略。当达到拥塞（超时）后，会把拥塞窗口重置为 1，慢启动阈值会设置为拥塞时刻窗口的一半，循环这个过程。但是超时的原因不一定是因为网络拥塞，也有可以发送方那一刻刚好丢包了。所以就有了快重传和快恢复进行优化， 	
3. 快重传。指的是使发送方尽快重传丢失报文，而不是等超时避免去触发慢启动。所以接受方要收到失序报文后马上发送重复确认以及发送方收到三个重复的接受报文要接受重发。快重传成功后，就会执行快恢复算法。 	
4. 快恢复。一般是将慢启动阈值和拥塞窗口都调整为现有窗口的一半，之后进行拥塞避免算法，也有实现是把调整为一半后，在增加3个MSS。 

### TCP的粘包和拆包

首先，TCP面向字节流，没有“包”的概念，包只是用来描述这种现象。

原因：应用程序写入的字节大小小于(并且间隔短)/大于socket发送缓冲区的大小。

解决：固定长度、分隔符、将消息分为头部和消息体、自定义协议

### TCP握手挥手状态变化

握手：

- 发送者：close -> sync_sent -> established 

- 接受者：lisetn -> sync_recv - > established

挥手：

- 发起者：established -> fin_wait_1 -> fin_wait_2 - > time_wait -> close 

- 接受者：established -> close_wait -> last_ack -> close

### TCP协议的三次握手和四次挥手？为什么是三次和四次？

**三次握手**：1. 因为 TCP 连接是全双工，客户端和服务端都需要具备收和发的功能，三次的握手就能够让双方都知道对方是具备收和发的功能的。 	二次握手，会让客户端知道服务端都会收和发，但缺了一次握手会让服务端不知道客户端可以收。 2. 二次握手有可能会建立多余的连接，因为发起第一次握手时，有可能因为网络原因没有到达服务端处，会重试在发送一次建立连接，而前面的那次因为网络延迟又到达了服务端处，最后的结果会导致建立了两个连接，造成资源的浪费

**四次挥手**：a. tcp 是全双工的连接，双方都需要告知对方关闭，告知时都需要经过一个来回 第二次和第三次挥手时，服务端的 ack + fin 有时不能一起回复。因为第一次挥手时，客户端告知了服务端要关闭连接，但是服务端可能还有数据要发给客户端处理，所以先回复一个 ack 的应答，再服务端主动关闭连接发起 fin 之前，还有剩余的数据包需要发送过

- 三次握手

  三次握手的目的在于让双方知道对方具备收和方的功能，交换双方的序列号，双方的数据滑动窗口，为之后的可靠性传输做准备 
  
  **第一次握手**，客户端从 close 变成 syn_send，生成自身的序列号发放给已经在 listen 的服务端 
  
  **第二次握手**，服务端收到后，状态变成 syn_recv，自己也生成序列号，加上客户端发过来的序列号返回过去。这一次握手相互交换同步了对方的序列号，之后的传输中会带上序列号去保证传输有序 

  **第三次握手**，客户端收到后，变成监听 established 状态，同时知会服务端已经收到了他的序列号，服务端也会进入监听状态 established 。之后开始传输。
  
- 四次挥手

  tcp 四次挥手是关闭 tcp 连接的过程，而因为 tcp 是全双工的，所以客户端和服务端要相互和对方传递自身要关闭的信息，需要两个两回 这里认为发起关闭连接的一端为客户端，另外为服务端 

  1. 客户端向服务端发起自身要关闭连接的 FIN 请求（客户端的状态变为 FIN_WAIT_1） 	

  2. 服务端接受到了客户端要关闭的请求，同时返回 ACK 应答请求，之后服务端继续把一些要发给客户端的数据处理完发过去（服务端状态变为 close_wait 等待自身关闭，客户端收到后变成 FIN_WAIT_2） 	
  2. 服务端发完了剩余的数据，自身也要开始关闭连接了，向客户端发送自身要关闭的 FIN 请求（服务端状态变成了 LAST_ACK（等待最后的确认应答报文状态），客户端收到后变成了 time_wait 状态，等待一定时间后向服务端发送应答报文） 
  2. 客户端向服务端发送 ack 应答报文，表示收到服务端的关闭报文（服务端收到后马上变成 close 状态，客户端维持 time_wait 状态 再等待 2MSL 后 close）

### tcp 四次挥手中的第二次和第三次能不能合并 

可以合并 

tcp 中第一二次挥手是客户端向服务端传达自己要关闭的信息，第三四次是服务端向客户端传达自己要关闭的信息。其中的第二次和第三次期间，可能服务端还有数据要发给客户端，所以，要等到服务端没有数据发送后才会发送第三次挥手的信息。但是如果服务端接到第二次挥手的通知时，如果没有要继续发送的信息，也是可以合并第二次和第三次回收的请求一起发给客户端

### 客户端有大量 timewait 是什么原因

- 原因 

  在高并发的场景下，存在大量 time_wait 状态的 TCP 连接是正常的，是因为

  1. 有大量 tcp 短连接的存在。高并发下建立了许多 tcp 连接，完成业务处理后马上断开了连接，导致有大量处于 time_wait 状态的 tcp 连接 		
  2. tcp 四次挥手的关闭机制。因为存在「延迟的数据包数据」和「最后一次握手可能会发生丢包」这两种情况，所以有 time_wait 的机制去保证 tcp 连接能够正常关闭 	

- 危害

  大量 time_wait 存在可能导致连接数被用尽，无法创建新链接 	 

- 解决方案

  1. 客户端处，尽量建立 tcp 长连接进行复用 
  1. 服务端处，允许 time_wait 状态的连接可以被复用和减少 time_wait 的时间（但是可能会存在旧连接数据包乱串和旧连接没有正常关闭的问题）

## HTTP

### 什么是HTTP与HTTPS有什么区别？

1、HTTP的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头

2、HTTP是不安全的，而 HTTPS 是安全的

3、HTTP标准端口是80 ，而 HTTPS 的标准端口是443

4、在OSI网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层

5、HTTP无法加密，而HTTPS 对传输的数据进行加密

6、HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书

### 什么是Http协议无状态协议?怎么解决Http协议无状态协议?

无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。
也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。
可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，
当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“

### HTTP请求报文与响应报文格式？

- 请求报文包含： 
  1、请求行：包含请求方法、URI、HTTP版本信息 
  2、请求头部字段
  3、空行
  4、请求内容实体


  - 响应报文包含： 
    1、状态行：包含HTTP版本、状态码、状态码的原因短语 
    2、响应头部字段
    3、空行 
    4、响应内容实体

### HTTP常见的状态码有哪些？

**1XX系列**：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。

**2XX系列**：代表请求已成功被服务器接收、理解、并接受。
200状态码：表示请求已成功，即将返回。
201状态码：表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。

202状态码：服务器已接受请求，但尚未处理

**3XX系列**：重定向。
301状态码：被请求的资源已永久移动到新位置，自动跳转。

302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求

304自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。

**4XX系列**：表示请求错误。
401状态码：请求要求身份验证。
403状态码：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且
这个请求也不应该被重复提交。

404状态码：请求失败，资源不存在以及未考虑到的情况。

**5xx系列**：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。
500状态码：无法完成对请求的处理。（panic）
503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。

### http1.0、http1.1、http2.0有什么区别？

- http1.0和http1.1区别：
  	1、http1.1默认开启长连接keep-alive，在一个TCP连接(一次完整的tcp握手和挥手)上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。
  	2、http1.0客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。
  	3、http1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。

- http1.1和http2.0区别:
  1、http2.0在1.1的基础上增加了多路复用，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
  http1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。
  2、http1.1不支持header数据的压缩，http2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
  3、http2.0引入了server push，它允许服务端推送资源给浏览器，免得客户端再次创建连接发送请求到服务器端获取。(例如：客户端向服务器发送一个获取html的请求，
  不需要再次请求去获取html所依赖的css、js，而是在第一次html请求时，服务器端主动的都推送给客户端)

## 其他

### ProtoBuff协议相比其它有什么好处？

pb是一种轻便高效的"结构化数据"存储格式，可以用于"结构化数据"的序列化和反序列化。
		1、跨语言，支持大多数语言开发，代码开源，运行稳定可靠。
		2、性能好、效率高，占据空间和运行时间相比json和xml小，二进制序列化格式，数据压缩紧凑，占据字节数小。
		3、支持向后向前兼容，比如向后兼容：A、B两模块，B升级有"statue"属性，可设置为非必填或者缺省，这样A就被兼容了。
		4、适合数据大、传输速率敏感的场合使用。
		5、支持数据类型多。
		6、数据结构化定义灵活，可嵌套定义。
