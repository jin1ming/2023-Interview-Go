[TOC]

## 通用

### 浏览器访问一个网站，都经历了怎样一个流程？

1.  **产生http请求**
	请求报文包含请求行（方法、URL、版本）、消息头（字段名、字段值）、消息体
	响应报文包括状态行（版本、状态码、短语）、消息头（字段名、字段值）、消息体
2. **dns查询**

	查询dns缓存和hosts文件->客户端查询本地dns服务器->本地dns服务器查询根域名服务器->根域名服务器返回顶级域名服务器地址->本地dns服务器请求顶级域名服务器->顶级域名服务器返回权威dns服务器->本地dns服务器请求权威dns服务器->本地dns将ip返回给客户端
3. **tcp传输**

	**tcp报文**
	源端口号（16b）、目的端口号（16b）
	序号（32b）、确认序列（32b）
	首部长度（4b）、保留（6b）、状态位（urg、ack、psh、rst、syn、fin）、窗口大小（16b）、校验和（16b）、紧急指针（16b）
	选项、数据
	**三次握手**
	client(close->syn_sent)->SYN->server(listen->syn_rcvd)->SYN+ACK->client(syn_sent->established)->ACK->server(established)
	**分割数据**
	HTTP请求报文超过了MSS时需要分块
	MSS(1460字节) = 1500(MTU) - TCP报头(20) - IP报头(20)
4. **IP**

	**IP报文**
	版本（4b）、首部长度（4b）、服务类型TOS（8b）
	总长度（16b）、标识（16b）
	标志（3b）、片偏移（13b）、TTL（8b）、协议（8b）
	首部校验和（16b）、源IP地址（32b）、目标IP地址（32b）
	选项、数据
5. **MAC与ARP**

	**MAC包头**
	接收方mac地址（48b）、发送方mac地址（48b）、协议类型（16b，IP？ARP？）
6. **其它**

	网卡、交换机、路由器

### 网络的457层

应用层、传输层、网络层、数据链路层

应：HTTP、FTP、Telnet、DNS、SMTP；传：UDP、TCP、tls；网：IP、ICMP ；数：ARP 

应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

应用层、运输层、网络层、数据链路层、物理层

## TCP/UDP

### TCP协议和UDP协议有什么区别？

连接/无连接、 1-1 / m-n、可靠性、拥塞控制、流量控制
、首部开销（20字节/8字节）

传输方式

-   TCP 是流式传输，没有边界，但保证顺序和可靠。
-   UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

分片不同

-   TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
-   UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

### UDP
头部：
源端口号（16b）、目标端口号（16b）、包长度（16b）、校验和（16b）、数据

### TCP握手挥手

**三次握手**

![握手阶段协商 MSS](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzI0LmpwZw?x-oss-process=image/format,png)	client(close->syn_sent)->SYN
	->server(listen->syn_rcvd)->SYN+ACK
	->client(syn_sent->established)->ACK
	->server(established)
**四次挥手**
	client(established->fin_wait1)->FIN
	->server(established->closed_wait)->ACK
	->client(fin_wait_1->fin_wait_2)
	->server(closed_wait->last_ack)->FIN
	->client(fin_wait_2->time_wait->2msl->close)->ACK
	->server(last_ack->close)

### TCP的粘包和拆包

首先，TCP面向字节流，没有“包”的概念，包只是用来描述这种现象。

原因：应用程序写入的字节大小小于(并且间隔短)/大于socket发送缓冲区的大小。

解决：固定长度、分隔符、将消息分为头部和消息体、自定义协议

### TCP为什么是三次和四次？

不使用「两次握手」和「四次握手」的原因：

-   「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
-   「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

### TCP可靠性保证：

1. 分割成块发送 2. 超时重传 3. 序列号，接收方排序后把有效数据传送给应用层 4. 校验和：首部和数据的检验和 5. 超时重传 6. 流量控制 7. 拥塞控制 8. 重复数据处理

#### TCP重传

- 超时重传（数据包丢失、确认应答丢失）: 超时重传时间 RTO 的值应该略大于报文往返 RTT 的值
- 快速重传: 当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。
- SACK(选择性确认)：在 TCP 头部「选项」字段里加一个 SACK ，它可以将已收到的数据的信息发送给「发送方」，只重传丢失的数据。
- D-SACK：使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。

#### 滑动窗口

无需等待确认应答，而可以继续发送数据的最大值。

通常窗口的大小是由接收方的窗口大小来决定的。

#### 流量控制

TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。

#### 拥塞控制

- 慢启动：发包个数指数增长，直到慢启动门限 `ssthresh`（一般为65535）。
- 拥塞避免：线性增长，直到出现丢包需要重传。
- 拥塞发生：触发超时重传：`ssthresh` 设为 `cwnd/2`，`cwnd` 重置为 初始值； 触发快速重传：`cwnd = cwnd/2`，`ssthresh = cwnd`，进入快速恢复。
- 快速恢复：快速重传和快速恢复算法一般同时使用。
  - 拥塞窗口 `cwnd = ssthresh + n `（n个重复ack）；
  - 重传丢失的数据包；
  - 如果再收到重复的 ACK，那么 cwnd 增加 1；
  - 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

### 客户端有大量 `timewait` 是什么原因

- 原因: 在高并发的场景下，存在大量 time_wait 状态的 TCP 连接是正常的，是因为: **1. 有大量 tcp 短连接的存在。**高并发下建立了许多 tcp 连接，完成业务处理后马上断开了连接，导致有大量处于 time_wait 状态的 tcp 连接; **2. tcp 四次挥手的关闭机制**。因为存在「延迟的数据包数据」和「最后一次握手可能会发生丢包」这两种情况，所以有 time_wait 的机制去保证 tcp 连接能够正常关闭 	

- 危害:大量 time_wait 存在可能导致连接数被用尽，无法创建新链接 	 

- 解决方案: 1. 客户端处，尽量建立 tcp 长连接进行复用 2. 服务端处，允许 time_wait 状态的连接可以被复用和减少 time_wait 的时间（但是可能会存在旧连接数据包乱串和旧连接没有正常关闭的问题）


### TCP 半连接队列和全连接队列

半连接队列，也称 SYN 队列；全连接队列，也称 accept 队列；

`tcp_abort_on_overflow`：0->扔`ack`，1->发`reset`。`connection reset by peer`是全连接队列溢出，应当设置0.

TCP 全连接队列的最大值取决于 `somaxconn` 和 `backlog` 之间的最小值。

SYN攻击：

1. `/proc/sys/net/ipv4/tcp_syncookies`设置为1。

   0 值，表示关闭该功能；1 值，表示仅当 SYN 半连接队列放不下时，再启用它；2 值，表示无条件开启功能；

2. 增大半连接队列：增大`tcp_max_syn_backlog、somaxconn、backlogHTTP`

3. 减少 `SYN+ACK` 重传次数：`tcp_synack_retries`

### 什么是HTTP与HTTPS有什么区别？

1、HTTP的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头

2、HTTP是不安全的，而 HTTPS 是安全的

3、HTTP标准端口是80 ，而 HTTPS 的标准端口是443

4、在OSI网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层

5、HTTP无法加密，而HTTPS 对传输的数据进行加密

6、HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书

### TLS握手

1. **ClientHello**：（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。（2）客户端生产的随机数（`Client Random`），后面用于生成「会话秘钥」条件之一。（3）客户端支持的密码套件列表，如 RSA 加密算法。

2. **SeverHello**：（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。（2）服务器生产的随机数（`Server Random`），也是后面用于生产「会话秘钥」条件之一。（3）确认的密码套件列表，如 RSA 加密算法。（4）服务器的数字证书。

3. **客户端回应**：客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会**从数字证书中取出服务器的公钥**，然后使用它加密报文，向服务器发送如下信息：（1）一个随机数（`pre-master key`）。该随机数会被服务器公钥加密。（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。**服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。

4. **服务器的最后回应**：服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发送最后的信息：（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

   至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容

### 什么是Http协议无状态协议?怎么解决Http协议无状态协议?

无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。
也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。
可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，
当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“

### HTTP请求报文与响应报文格式？

- 请求报文包含： 
  1、请求行：包含请求方法、URI、HTTP版本信息 
  2、请求头部字段
  3、空行
  4、请求内容实体


  - 响应报文包含： 
    1、状态行：包含HTTP版本、状态码、状态码的原因短语 
    2、响应头部字段
    3、空行 
    4、响应内容实体

### HTTP常见的状态码有哪些？

**1XX系列**：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。

**2XX系列**：代表请求已成功被服务器接收、理解、并接受。200状态码：表示请求已成功，即将返回。201状态码：表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。202状态码：服务器已接受请求，但尚未处理

**3XX系列**：重定向。301状态码：被请求的资源已永久移动到新位置，自动跳转。302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求。304自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。

**4XX系列**：表示请求错误。401状态码：请求要求身份验证。403状态码：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。404状态码：请求失败，资源不存在以及未考虑到的情况。

**5xx系列**：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。500状态码：无法完成对请求的处理。（panic）503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。

### Get/Post

GET 的语义是从服务器获取指定的资源;POST 的语义是根据请求负荷（报文body）对指定的资源做出处理.

- **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，**可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签**。
- **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以，**浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签**。

### http1.0、http1.1、http2.0有什么区别？

- http1.0和http1.1区别：
  	1、http1.1默认开启长连接keep-alive，在一个TCP连接(一次完整的tcp握手和挥手)上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。
  	2、http1.0客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。
  	3、http1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。

- http1.1和http2.0区别:
  1、http2.0在1.1的基础上增加了多路复用，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
  http1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。
  2、http1.1不支持header数据的压缩，http2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
  3、http2.0引入了server push，它允许服务端推送资源给浏览器，免得客户端再次创建连接发送请求到服务器端获取。(例如：客户端向服务器发送一个获取html的请求，
  不需要再次请求去获取html所依赖的css、js，而是在第一次html请求时，服务器端主动的都推送给客户端)

## 其他

### ProtoBuff协议相比其它有什么好处？

pb是一种轻便高效的"结构化数据"存储格式，可以用于"结构化数据"的序列化和反序列化。
		1、跨语言，支持大多数语言开发，代码开源，运行稳定可靠。
		2、性能好、效率高，占据空间和运行时间相比json和xml小，二进制序列化格式，数据压缩紧凑，占据字节数小。
		3、支持向后向前兼容，比如向后兼容：A、B两模块，B升级有"statue"属性，可设置为非必填或者缺省，这样A就被兼容了。
		4、适合数据大、传输速率敏感的场合使用。
		5、支持数据类型多。
		6、数据结构化定义灵活，可嵌套定义。