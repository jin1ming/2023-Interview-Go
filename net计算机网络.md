[TOC]

## 通用

### 浏览器访问一个网站，都经历了怎样一个流程？

1.  **产生http请求**
	请求报文包含请求行（方法、URL、版本）、消息头（字段名、字段值）、消息体
	响应报文包括状态行（版本、状态码、短语）、消息头（字段名、字段值）、消息体
2. **dns查询**
	查询dns缓存和hosts文件->客户端查询本地dns服务器->本地dns服务器查询根域名服务器->根域名服务器返回顶级域名服务器地址->本地dns服务器请求顶级域名服务器->顶级域名服务器返回权威dns服务器->本地dns服务器请求权威dns服务器->本地dns将ip返回给客户端
3. **tcp传输**
	**tcp报文**
	源端口号（16b）、目的端口号（16b）
	序号（32b）、确认序列（32b）
	首部长度（4b）、保留（6b）、状态位（urg、ack、psh、rst、syn、fin）、窗口大小（16b）、校验和（16b）、紧急指针（16b）
	选项、数据
	**三次握手**
	client(close->syn_sent)->SYN->server(listen->syn_rcvd)->SYN+ACK->client(syn_sent->established)->ACK->server(established)
	**分割数据**
	HTTP请求报文超过了MSS时需要分块
	MSS(1460字节) = 1500(MTU) - TCP报头(20) - IP报头(20)
4. **IP**
	**IP报文**
	版本（4b）、首部长度（4b）、服务类型TOS（8b）
	总长度（16b）、标识（16b）
	标志（3b）、片偏移（13b）、TTL（8b）、协议（8b）
	首部校验和（16b）、源IP地址（32b）、目标IP地址（32b）
	选项、数据
5. **MAC与ARP**
	**MAC包头**
	接收方mac地址（48b）、发送方mac地址（48b）、协议类型（16b，IP？ARP？）
6. **其它**
	网卡、交换机、路由器
	
### 网络的457层

应用层、传输层、网络层、数据链路层

应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

应用层、运输层、网络层、数据链路层、物理层

## TCP/UDP

### TCP协议和UDP协议有什么区别？

连接/无连接、 1-1 / m-n、可靠性、拥塞控制、流量控制
、首部开销（20字节/8字节）

传输方式

-   TCP 是流式传输，没有边界，但保证顺序和可靠。
-   UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

分片不同_

-   TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
-   UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

### UDP
头部：
源端口号（16b）、目标端口号（16b）、包长度（16b）、校验和（16b）、数据

### TCP握手挥手

**三次握手**
	client(close->syn_sent)->SYN
	->server(listen->syn_rcvd)->SYN+ACK
	->client(syn_sent->established)->ACK
	->server(established)
**四次挥手**
	client(established->fin_wait1)->FIN
	->server(established->closed_wait)->ACK
	->client(fin_wait_1->fin_wait_2)
	->server(closed_wait->last_ack)->FIN
	->client(fin_wait_2->time_wait->2msl->close)->ACK
	->server(last_ack->close)

### TCP的粘包和拆包

首先，TCP面向字节流，没有“包”的概念，包只是用来描述这种现象。

原因：应用程序写入的字节大小小于(并且间隔短)/大于socket发送缓冲区的大小。

解决：固定长度、分隔符、将消息分为头部和消息体、自定义协议

### TCP为什么是三次和四次？

不使用「两次握手」和「四次握手」的原因：

-   「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
-   「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

### tcp 四次挥手中的第二次和第三次能不能合并 

可以合并 

tcp 中第一二次挥手是客户端向服务端传达自己要关闭的信息，第三四次是服务端向客户端传达自己要关闭的信息。其中的第二次和第三次期间，可能服务端还有数据要发给客户端，所以，要等到服务端没有数据发送后才会发送第三次挥手的信息。但是如果服务端接到第二次挥手的通知时，如果没有要继续发送的信息，也是可以合并第二次和第三次回收的请求一起发给客户端

### 客户端有大量 timewait 是什么原因

- 原因 

  在高并发的场景下，存在大量 time_wait 状态的 TCP 连接是正常的，是因为

  1. 有大量 tcp 短连接的存在。高并发下建立了许多 tcp 连接，完成业务处理后马上断开了连接，导致有大量处于 time_wait 状态的 tcp 连接 		
  2. tcp 四次挥手的关闭机制。因为存在「延迟的数据包数据」和「最后一次握手可能会发生丢包」这两种情况，所以有 time_wait 的机制去保证 tcp 连接能够正常关闭 	

- 危害

  大量 time_wait 存在可能导致连接数被用尽，无法创建新链接 	 

- 解决方案

  1. 客户端处，尽量建立 tcp 长连接进行复用 
  1. 服务端处，允许 time_wait 状态的连接可以被复用和减少 time_wait 的时间（但是可能会存在旧连接数据包乱串和旧连接没有正常关闭的问题）

## HTTP

### 什么是HTTP与HTTPS有什么区别？

1、HTTP的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头

2、HTTP是不安全的，而 HTTPS 是安全的

3、HTTP标准端口是80 ，而 HTTPS 的标准端口是443

4、在OSI网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层

5、HTTP无法加密，而HTTPS 对传输的数据进行加密

6、HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书

### 什么是Http协议无状态协议?怎么解决Http协议无状态协议?

无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。
也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。
可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，
当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“

### HTTP请求报文与响应报文格式？

- 请求报文包含： 
  1、请求行：包含请求方法、URI、HTTP版本信息 
  2、请求头部字段
  3、空行
  4、请求内容实体


  - 响应报文包含： 
    1、状态行：包含HTTP版本、状态码、状态码的原因短语 
    2、响应头部字段
    3、空行 
    4、响应内容实体

### HTTP常见的状态码有哪些？

**1XX系列**：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。

**2XX系列**：代表请求已成功被服务器接收、理解、并接受。
200状态码：表示请求已成功，即将返回。
201状态码：表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。

202状态码：服务器已接受请求，但尚未处理

**3XX系列**：重定向。
301状态码：被请求的资源已永久移动到新位置，自动跳转。

302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求

304自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。

**4XX系列**：表示请求错误。
401状态码：请求要求身份验证。
403状态码：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且
这个请求也不应该被重复提交。

404状态码：请求失败，资源不存在以及未考虑到的情况。

**5xx系列**：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。
500状态码：无法完成对请求的处理。（panic）
503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。

### http1.0、http1.1、http2.0有什么区别？

- http1.0和http1.1区别：
  	1、http1.1默认开启长连接keep-alive，在一个TCP连接(一次完整的tcp握手和挥手)上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。
  	2、http1.0客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。
  	3、http1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。

- http1.1和http2.0区别:
  1、http2.0在1.1的基础上增加了多路复用，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
  http1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。
  2、http1.1不支持header数据的压缩，http2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
  3、http2.0引入了server push，它允许服务端推送资源给浏览器，免得客户端再次创建连接发送请求到服务器端获取。(例如：客户端向服务器发送一个获取html的请求，
  不需要再次请求去获取html所依赖的css、js，而是在第一次html请求时，服务器端主动的都推送给客户端)

## 其他

### ProtoBuff协议相比其它有什么好处？

pb是一种轻便高效的"结构化数据"存储格式，可以用于"结构化数据"的序列化和反序列化。
		1、跨语言，支持大多数语言开发，代码开源，运行稳定可靠。
		2、性能好、效率高，占据空间和运行时间相比json和xml小，二进制序列化格式，数据压缩紧凑，占据字节数小。
		3、支持向后向前兼容，比如向后兼容：A、B两模块，B升级有"statue"属性，可设置为非必填或者缺省，这样A就被兼容了。
		4、适合数据大、传输速率敏感的场合使用。
		5、支持数据类型多。
		6、数据结构化定义灵活，可嵌套定义。
