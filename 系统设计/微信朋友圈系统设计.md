# 微信朋友圈系统设计

## 一、核心功能

| 功能 | 说明 |
|------|------|
| 发布动态 | 文字、图片、视频、链接 |
| 查看 Feed | 只看好友动态（非公开） |
| 互动 | 点赞、评论（仅共同好友可见） |
| 权限控制 | 谁可以看、不给谁看、三天/半年可见 |

---

## 二、整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                          客户端                                  │
└───────────────────────────┬─────────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────────┐
│                     API Gateway (Nginx)                          │
│                   限流、鉴权、负载均衡                             │
└───────────────────────────┬─────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
┌───────▼───────┐   ┌───────▼───────┐   ┌───────▼───────┐
│   动态服务     │   │   Feed服务    │   │   互动服务     │
│  (发布/删除)   │   │  (时间线)     │   │ (点赞/评论)   │
└───────┬───────┘   └───────┬───────┘   └───────┬───────┘
        │                   │                   │
┌───────▼───────────────────▼───────────────────▼───────┐
│                      Kafka                             │
│              异步写扩散、削峰填谷                         │
└───────┬───────────────────┬───────────────────┬───────┘
        │                   │                   │
┌───────▼───────┐   ┌───────▼───────┐   ┌───────▼───────┐
│  MySQL 分库    │   │  Redis 集群   │   │     OSS       │
│   (持久化)     │   │   (缓存)      │   │  (图片视频)    │
└───────────────┘   └───────────────┘   └───────────────┘
```

---

## 三、Feed 流设计

### 方案对比

| 方案 | 原理 | 优点 | 缺点 |
|------|------|------|------|
| **推模式（写扩散）** | 发布时推送到所有好友的收件箱 | 读取快 | 大V发布慢，存储成本高 |
| **拉模式（读扩散）** | 读取时拉取所有好友的动态 | 发布快 | 读取慢，需聚合排序 |
| **推拉结合** | 普通用户推，大V用户拉 | 平衡读写 | 实现复杂 |

### 朋友圈选择：推模式

**原因**：好友上限 5000，扩散范围可控；刷朋友圈频率高，读性能优先。

---

## 四、数据模型

```sql
-- 动态表（发件箱）
CREATE TABLE moments (
    id BIGINT PRIMARY KEY,
    user_id BIGINT,
    content TEXT,
    media_urls JSON,
    visibility TINYINT,     -- 0公开 1私密 2部分可见
    created_at TIMESTAMP,
    INDEX idx_user_time (user_id, created_at DESC)
);

-- 时间线表（收件箱）
CREATE TABLE timeline (
    user_id BIGINT,         -- 收件人
    moment_id BIGINT,
    author_id BIGINT,
    created_at TIMESTAMP,
    PRIMARY KEY (user_id, created_at, moment_id)
);

-- 点赞表
CREATE TABLE likes (
    moment_id BIGINT,
    user_id BIGINT,
    PRIMARY KEY (moment_id, user_id)
);

-- 评论表
CREATE TABLE comments (
    id BIGINT PRIMARY KEY,
    moment_id BIGINT,
    user_id BIGINT,
    reply_to_user_id BIGINT,
    content VARCHAR(1000),
    created_at TIMESTAMP
);
```

### 分库策略

- **moments**：按 user_id % 64 分库
- **timeline**：按 user_id % 64 分库（收件人维度）
- **comments**：按 moment_id % 64 分库

---

## 五、Redis 核心应用

### 1. Timeline 缓存（ZSet）

```redis
# 用户收件箱：score=时间戳
ZADD timeline:{user_id} {timestamp} {moment_id}

# 刷朋友圈：倒序分页
ZREVRANGEBYSCORE timeline:123 +inf {last_timestamp} LIMIT 0 20

# 控制大小，只保留最近1000条
ZREMRANGEBYRANK timeline:123 0 -1001
```

### 2. 动态详情缓存（Hash）

```redis
HSET moment:456 content "今天天气真好" user_id 123 media "[url1,url2]"
EXPIRE moment:456 604800  # 7天过期
```

### 3. 好友关系（Set）

```redis
# 用户好友集合
SADD friends:123 456 789

# 计算共同好友（评论可见性）
SINTER friends:123 friends:456

# 判断是否好友
SISMEMBER friends:123 456
```

### 4. 点赞数据（Set + String）

```redis
SADD likes:moment:456 123 789      # 点赞用户集合
INCR likes:count:456               # 点赞计数
SISMEMBER likes:moment:456 123     # 判断是否点赞
```

### 5. 分布式锁（防重复发布）

```redis
SET lock:publish:123 uuid NX PX 5000
```

---

## 六、Kafka 应用

### 写扩散异步化

```go
// 发布动态
func PublishMoment(moment *Moment) {
    // 1. 写入 MySQL
    db.Create(moment)
    
    // 2. 发送到 Kafka，异步扩散
    kafka.Send("moment-fanout", &FanoutMessage{
        MomentID:  moment.ID,
        AuthorID:  moment.UserID,
        CreatedAt: moment.CreatedAt,
    })
}

// 消费者：写入好友 timeline
func ConsumeFanout(msg *FanoutMessage) {
    friends := getFriends(msg.AuthorID)
    for _, friendID := range friends {
        redis.ZAdd("timeline:"+friendID, msg.CreatedAt, msg.MomentID)
    }
}
```

### Topic 设计

| Topic | 用途 | 分区策略 |
|-------|------|----------|
| `moment-fanout` | 动态写扩散 | 按 author_id hash |
| `moment-delete` | 删除扩散 | 按 author_id hash |
| `interaction` | 点赞评论通知 | 按 moment_id hash |

---

## 七、核心流程

### 发布动态

```
1. 写入 moments 表
2. 获取好友列表（过滤权限）
3. 发送 Kafka 消息
4. 消费者异步写入每个好友的 timeline
5. 图片/视频异步上传 CDN
```

### 刷朋友圈

```
1. 查询 Redis timeline（ZSet 倒序）
2. 批量获取动态详情（先查缓存，miss 查 DB）
3. 批量获取点赞/评论（只显示共同好友）
4. 下拉加载用 cursor 分页
```

### 共同好友可见

```go
func getVisibleInteractions(momentId, viewerId int64) {
    authorFriends := redis.SMembers("friends:" + authorId)
    viewerFriends := redis.SMembers("friends:" + viewerId)
    commonFriends := intersect(authorFriends, viewerFriends)
    // 只返回 commonFriends 的点赞和评论
}
```

---

## 八、高可用设计

### Redis 高可用

```
Redis Cluster（6节点，3主3从）
  ├── 主1 (slot 0-5460)     ← 从1
  ├── 主2 (slot 5461-10922) ← 从2
  └── 主3 (slot 10923-16383)← 从3
```

### Kafka 高可用

```
3 Broker，每个 Topic 3副本
  - acks=all：保证消息不丢
  - min.insync.replicas=2
```

### 降级策略

```go
func GetTimeline(userID int64) []*Moment {
    moments, err := redis.ZRevRange("timeline:"+userID, 0, 20)
    if err != nil {
        // Redis 不可用，降级到 DB
        return db.Query("SELECT * FROM timeline WHERE user_id=? ORDER BY created_at DESC LIMIT 20", userID)
    }
    return moments
}
```

---

## 九、进阶优化：冷热分离

朋友圈数据的访问特性：**极热极冷**（绝大多数只看最近 3 天）。

### 存储架构升级

| 数据分层 | 存储介质 | 数据范围 | 访问方式 |
|----------|----------|----------|----------|
| **热数据** | Redis ZSet | 最近 3-7 天 | 99% 流量，直接读缓存 |
| **温数据** | MySQL (Timeline) | 最近 3 个月 | 缓存未命中时回源 DB |
| **冷数据** | HBase / TiDB | 3 个月前 | 查看历史动态（低频），异步查询 |

### 归档策略
1. 定时任务（Daily Job）将 MySQL 中超过 3 个月的数据迁移到 HBase。
2. 删除 MySQL 中的历史数据，保持单表轻量。

---

## 十、容量估算

| 指标 | 估算 |
|------|------|
| DAU | 5亿 |
| 人均好友 | 200 |
| 日发布率 | 5%（2500万条/天） |
| 写扩散量 | 2500万 × 200 = 50亿条/天 |
| Redis 内存 | 5亿用户 × 1000条 × 16B ≈ 8TB |
| Kafka 吞吐 | 50亿/86400 ≈ 6万 TPS |

---

## 十、面试追问

| 问题 | 回答 |
|------|------|
| 为什么不用拉模式？ | 好友上限 5000 可控，读多写少，推模式读性能好 |
| Redis 挂了怎么办？ | Cluster 自动故障转移 + DB 降级兜底 |
| 消息积压怎么办？ | 扩消费者 + 临时跳过非核心逻辑 |
| 缓存穿透？ | 布隆过滤器 + 空值缓存 |
| 热点动态？ | 本地缓存 + Redis 多副本读 |
| 如何处理删好友？ | 异步清理 timeline，或读时校验好友关系 |
| 如何保证时序？ | 服务端生成时间戳，timeline 按时间排序 |
