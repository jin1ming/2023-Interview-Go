# 支付系统设计

## 一、核心功能

| 功能 | 说明 |
|------|------|
| 统一收银台 | 聚合多种支付方式 |
| 支付渠道对接 | 微信、支付宝、银行卡等 |
| 支付状态管理 | 待支付、支付中、已支付、已退款 |
| 退款 | 原路退回 |
| 对账 | 与渠道对账，保证资金准确 |

---

## 二、整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                        业务系统                              │
│                  （订单、会员、充值等）                        │
└─────────────────────────────┬───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                       支付网关                               │
│              （统一接口、路由、限流）                          │
└─────────────────────────────┬───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                       支付核心                               │
│           （支付单管理、状态机、幂等）                          │
└─────────────────────────────┬───────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────▼───────┐     ┌───────▼───────┐     ┌───────▼───────┐
│   微信支付     │     │   支付宝      │     │   银行卡      │
│   渠道适配     │     │   渠道适配    │     │   渠道适配    │
└───────────────┘     └───────────────┘     └───────────────┘
```

---

## 三、支付流程

### 统一下单

```go
func CreatePayment(req *PaymentRequest) (*PaymentResponse, error) {
    // 1. 幂等检查
    if existing := getPaymentByOrderID(req.OrderID); existing != nil {
        if existing.Status == StatusPaid {
            return nil, errors.New("订单已支付")
        }
        return existing, nil  // 返回已有支付单
    }
    
    // 2. 创建支付单
    payment := &Payment{
        PaymentID:   generatePaymentID(),
        OrderID:     req.OrderID,
        Amount:      req.Amount,
        Channel:     req.Channel,  // wechat/alipay
        Status:      StatusPending,
        ExpireAt:    time.Now().Add(30 * time.Minute),
        CreatedAt:   time.Now(),
    }
    db.Create(payment)
    
    // 3. 调用渠道下单
    channelResp, err := callChannel(payment)
    if err != nil {
        payment.Status = StatusFailed
        db.Save(payment)
        return nil, err
    }
    
    // 4. 返回支付参数
    return &PaymentResponse{
        PaymentID:  payment.PaymentID,
        PayParams:  channelResp.PayParams,  // 给客户端调起支付
    }, nil
}

// 调用支付渠道
func callChannel(payment *Payment) (*ChannelResponse, error) {
    switch payment.Channel {
    case "wechat":
        return wechatPay.UnifiedOrder(payment)
    case "alipay":
        return alipay.TradeCreate(payment)
    default:
        return nil, errors.New("不支持的支付渠道")
    }
}
```

### 支付回调

```go
func HandleCallback(channel string, body []byte) error {
    // 1. 验签
    if !verifySign(channel, body) {
        return errors.New("签名验证失败")
    }
    
    // 2. 解析回调
    callback := parseCallback(channel, body)
    
    // 3. 查询支付单
    payment := getPaymentByChannelOrderID(callback.ChannelOrderID)
    if payment == nil {
        return errors.New("支付单不存在")
    }
    
    // 4. 幂等检查
    if payment.Status == StatusPaid {
        return nil  // 已处理，直接返回成功
    }
    
    // 5. 更新支付状态
    if callback.Status == "SUCCESS" {
        payment.Status = StatusPaid
        payment.PaidAt = time.Now()
        payment.ChannelOrderID = callback.ChannelOrderID
    } else {
        payment.Status = StatusFailed
        payment.FailReason = callback.FailReason
    }
    db.Save(payment)
    
    // 6. 通知业务系统
    if payment.Status == StatusPaid {
        kafka.Send("payment-success", &PaymentSuccessEvent{
            PaymentID: payment.PaymentID,
            OrderID:   payment.OrderID,
            Amount:    payment.Amount,
        })
    }
    
    return nil
}
```

---

## 四、高阶优化

### 1. 掉单处理（主动轮询）

```go
// 仅依赖渠道回调是不够的（回调可能丢）
// 需要定时任务主动查询支付中状态的订单

func PollingTask() {
    // 查询创建超过 30s 且状态为 Pending 的支付单
    payments := db.Query("status = ? AND created_at < ?", StatusPending, now-30s)
    
    for _, p := range payments {
        // 调用微信/支付宝查询接口
        status := queryChannel(p.PaymentID)
        
        if status == "SUCCESS" {
            // 补单：更新状态，触发发货
            handleSuccess(p)
        } else if status == "CLOSED" {
            // 关单
            closePayment(p)
        }
        // 否则继续等待
    }
}
```

### 2. 冷热数据分离

```
支付流水数据量巨大，影响查询性能。

方案：
1. 热库：只存最近 3 个月数据（MySQL）。
2. 冷库：3 个月前数据归档到 HBase 或 TiDB。
3. 历史查询：C 端用户查历史账单走冷库，B 端后台走 ES。
```

---

## 五、幂等性设计

### 支付幂等

```go
// 同一订单只能有一个进行中的支付单
func CreatePayment(orderID int64) (*Payment, error) {
    // 分布式锁
    lockKey := fmt.Sprintf("lock:payment:%d", orderID)
    if !redis.SetNX(lockKey, "1", 10*time.Second) {
        return nil, errors.New("请勿重复提交")
    }
    defer redis.Del(lockKey)
    
    // 检查是否已有支付单
    existing := getPaymentByOrderID(orderID)
    if existing != nil {
        switch existing.Status {
        case StatusPaid:
            return nil, errors.New("订单已支付")
        case StatusPending:
            // 检查是否过期
            if existing.ExpireAt.After(time.Now()) {
                return existing, nil  // 返回已有支付单
            }
            // 已过期，关闭旧单
            existing.Status = StatusClosed
            db.Save(existing)
        }
    }
    
    // 创建新支付单
    // ...
}
```

### 回调幂等

```go
func HandleCallback(paymentID string, status string) error {
    // 使用数据库乐观锁
    result := db.Model(&Payment{}).
        Where("payment_id = ? AND status = ?", paymentID, StatusPending).
        Updates(map[string]interface{}{
            "status":  status,
            "paid_at": time.Now(),
        })
    
    if result.RowsAffected == 0 {
        // 已处理或状态不对，忽略
        return nil
    }
    
    // 继续后续处理...
}
```

---

## 五、退款流程

```go
func Refund(req *RefundRequest) (*Refund, error) {
    // 1. 查询原支付单
    payment := getPayment(req.PaymentID)
    if payment == nil || payment.Status != StatusPaid {
        return nil, errors.New("支付单不存在或未支付")
    }
    
    // 2. 检查可退金额
    refundedAmount := getRefundedAmount(req.PaymentID)
    if refundedAmount + req.Amount > payment.Amount {
        return nil, errors.New("退款金额超出可退金额")
    }
    
    // 3. 创建退款单
    refund := &Refund{
        RefundID:   generateRefundID(),
        PaymentID:  req.PaymentID,
        Amount:     req.Amount,
        Reason:     req.Reason,
        Status:     RefundStatusPending,
        CreatedAt:  time.Now(),
    }
    db.Create(refund)
    
    // 4. 调用渠道退款
    channelResp, err := callChannelRefund(payment, refund)
    if err != nil {
        refund.Status = RefundStatusFailed
        refund.FailReason = err.Error()
        db.Save(refund)
        return nil, err
    }
    
    // 5. 更新状态（等待渠道回调确认）
    refund.ChannelRefundID = channelResp.RefundID
    refund.Status = RefundStatusProcessing
    db.Save(refund)
    
    return refund, nil
}
```

---

## 六、对账系统

### 对账流程

```
1. 每日凌晨拉取渠道账单
2. 与本地支付记录逐笔比对
3. 生成差异报告
4. 人工处理异常
```

```go
// 对账任务
func Reconciliation(date string) (*ReconciliationReport, error) {
    report := &ReconciliationReport{Date: date}
    
    // 1. 拉取渠道账单
    channelBills := fetchChannelBills(date)
    
    // 2. 查询本地支付记录
    localPayments := getPaymentsByDate(date)
    
    // 3. 构建索引
    channelMap := make(map[string]*ChannelBill)
    for _, bill := range channelBills {
        channelMap[bill.ChannelOrderID] = bill
    }
    
    localMap := make(map[string]*Payment)
    for _, payment := range localPayments {
        localMap[payment.ChannelOrderID] = payment
    }
    
    // 4. 比对
    for channelOrderID, bill := range channelMap {
        local, exists := localMap[channelOrderID]
        if !exists {
            // 渠道有，本地无（长款）
            report.LongItems = append(report.LongItems, bill)
            continue
        }
        
        if bill.Amount != local.Amount {
            // 金额不一致
            report.AmountMismatch = append(report.AmountMismatch, &Mismatch{
                ChannelBill: bill,
                LocalPayment: local,
            })
        }
        
        delete(localMap, channelOrderID)
    }
    
    // 本地有，渠道无（短款）
    for _, local := range localMap {
        report.ShortItems = append(report.ShortItems, local)
    }
    
    // 5. 保存报告
    saveReport(report)
    
    return report, nil
}
```

### 异常处理

| 异常类型 | 说明 | 处理方式 |
|----------|------|----------|
| 长款 | 渠道有，本地无 | 查询渠道确认，补单 |
| 短款 | 本地有，渠道无 | 查询渠道确认，可能掉单 |
| 金额不一致 | 金额对不上 | 人工核查 |

---

## 七、数据模型

```sql
-- 支付单表
CREATE TABLE payments (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    payment_id VARCHAR(32) UNIQUE NOT NULL,
    order_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    amount BIGINT NOT NULL,           -- 分
    channel VARCHAR(20) NOT NULL,     -- wechat/alipay
    channel_order_id VARCHAR(64),     -- 渠道订单号
    status TINYINT NOT NULL,          -- 1待支付 2已支付 3已关闭 4已退款
    expire_at TIMESTAMP,
    paid_at TIMESTAMP,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    INDEX idx_order (order_id),
    INDEX idx_channel_order (channel_order_id),
    INDEX idx_created (created_at)
);

-- 退款单表
CREATE TABLE refunds (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    refund_id VARCHAR(32) UNIQUE NOT NULL,
    payment_id VARCHAR(32) NOT NULL,
    amount BIGINT NOT NULL,
    reason VARCHAR(200),
    channel_refund_id VARCHAR(64),
    status TINYINT NOT NULL,
    fail_reason VARCHAR(200),
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    INDEX idx_payment (payment_id)
);

-- 对账记录表
CREATE TABLE reconciliation_records (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    date DATE NOT NULL,
    channel VARCHAR(20) NOT NULL,
    total_count INT,
    total_amount BIGINT,
    match_count INT,
    long_count INT,
    short_count INT,
    status TINYINT,
    created_at TIMESTAMP,
    UNIQUE KEY uk_date_channel (date, channel)
);
```

---

## 八、安全设计

### 签名验证

```go
// 微信支付签名验证
func VerifyWechatSign(body []byte, signature string) bool {
    // 1. 获取微信平台证书
    cert := getWechatPlatformCert()
    
    // 2. 验证签名
    return rsa.VerifyPKCS1v15(cert.PublicKey, crypto.SHA256, 
        sha256.Sum256(body), signature)
}

// 支付宝签名验证
func VerifyAlipaySign(params map[string]string) bool {
    sign := params["sign"]
    delete(params, "sign")
    delete(params, "sign_type")
    
    // 按字母序拼接
    sortedStr := sortAndJoin(params)
    
    // RSA2 验签
    return rsa.VerifyPKCS1v15(alipayPublicKey, crypto.SHA256,
        sha256.Sum256([]byte(sortedStr)), sign)
}
```

### 敏感数据加密

```go
// 银行卡号加密存储
func EncryptCardNo(cardNo string) string {
    return aes.Encrypt(cardNo, secretKey)
}

// 日志脱敏
func MaskCardNo(cardNo string) string {
    if len(cardNo) < 8 {
        return "****"
    }
    return cardNo[:4] + "****" + cardNo[len(cardNo)-4:]
}
```

---

## 九、面试追问

| 问题 | 回答 |
|------|------|
| 如何保证支付幂等？ | 订单ID唯一约束 + 分布式锁 + 状态机 |
| 掉单怎么处理？ | 主动查询渠道 + 对账补单 |
| 如何防止重复支付？ | 同一订单只允许一个进行中的支付单 |
| 退款失败怎么办？ | 重试 + 人工处理 |
| 如何保证资金安全？ | 签名验证 + 对账 + 风控 |
| 高并发下如何保证一致性？ | 分布式锁 + 数据库乐观锁 + 最终一致性 |
