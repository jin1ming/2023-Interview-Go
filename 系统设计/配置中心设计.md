# 配置中心设计

## 一、核心功能

| 功能 | 说明 |
|------|------|
| 配置管理 | 增删改查配置项 |
| 实时推送 | 配置变更实时通知客户端 |
| 版本管理 | 配置历史、回滚 |
| 灰度发布 | 按比例、按IP、按用户灰度 |
| 多环境 | dev/test/prod 环境隔离 |

---

## 二、整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                      管理后台 (Web)                          │
└─────────────────────────────┬───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                      配置中心服务                             │
│              （API、推送、版本管理）                           │
└─────────────────────────────┬───────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────▼───────┐     ┌───────▼───────┐     ┌───────▼───────┐
│    MySQL      │     │    Redis      │     │   客户端SDK    │
│  （持久化）    │     │  （缓存）      │     │  （长轮询）    │
└───────────────┘     └───────────────┘     └───────────────┘
```

---

## 三、配置推送方案

### 方案对比

| 方案 | 原理 | 优点 | 缺点 |
|------|------|------|------|
| 定时轮询 | 客户端定时拉取 | 简单 | 延迟高，服务端压力大 |
| **长轮询** | 服务端 hold 请求 | 实时性好 | 实现复杂 |
| WebSocket | 长连接推送 | 实时 | 连接维护成本高 |

### 长轮询实现（Apollo 方案）

```go
// 服务端
func LongPolling(w http.ResponseWriter, r *http.Request) {
    appID := r.URL.Query().Get("app_id")
    clientVersion := r.URL.Query().Get("version")
    
    // 检查是否有新版本
    serverVersion := getLatestVersion(appID)
    if serverVersion > clientVersion {
        // 有更新，立即返回
        json.NewEncoder(w).Encode(getConfig(appID))
        return
    }
    
    // 无更新，hold 请求（最长 30 秒）
    ch := subscribe(appID)
    select {
    case <-ch:
        // 配置变更，返回新配置
        json.NewEncoder(w).Encode(getConfig(appID))
    case <-time.After(30 * time.Second):
        // 超时，返回 304
        w.WriteHeader(http.StatusNotModified)
    case <-r.Context().Done():
        // 客户端断开
        unsubscribe(appID, ch)
    }
}

// 配置变更时通知
func PublishConfig(appID string, config *Config) {
    // 1. 保存配置
    saveConfig(appID, config)
    
    // 2. 更新版本号
    incrVersion(appID)
    
    // 3. 通知所有订阅者
    notify(appID)
}
```

### 客户端 SDK

```go
type ConfigClient struct {
    appID      string
    serverURL  string
    version    int64
    config     map[string]string
    listeners  []func(key, value string)
    mu         sync.RWMutex
}

func (c *ConfigClient) Start() {
    go c.longPolling()
}

func (c *ConfigClient) longPolling() {
    for {
        resp, err := http.Get(fmt.Sprintf("%s/config?app_id=%s&version=%d",
            c.serverURL, c.appID, c.version))
        
        if err != nil {
            time.Sleep(5 * time.Second)
            continue
        }
        
        if resp.StatusCode == http.StatusOK {
            // 配置有更新
            var newConfig ConfigResponse
            json.NewDecoder(resp.Body).Decode(&newConfig)
            
            c.mu.Lock()
            c.version = newConfig.Version
            for k, v := range newConfig.Items {
                oldValue := c.config[k]
                c.config[k] = v
                if oldValue != v {
                    // 通知监听器
                    for _, listener := range c.listeners {
                        go listener(k, v)
                    }
                }
            }
            c.mu.Unlock()
        }
        // 304 或其他状态，继续轮询
    }
}

func (c *ConfigClient) Get(key string) string {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.config[key]
}
```

---

## 四、灰度发布

```go
type GrayRule struct {
    Type       string   // ip/user/percent
    Whitelist  []string // IP或用户白名单
    Percent    int      // 灰度比例
}

func GetConfigWithGray(appID, clientIP, userID string) *Config {
    // 1. 获取灰度规则
    rule := getGrayRule(appID)
    
    // 2. 判断是否命中灰度
    if rule != nil {
        switch rule.Type {
        case "ip":
            if contains(rule.Whitelist, clientIP) {
                return getGrayConfig(appID)
            }
        case "user":
            if contains(rule.Whitelist, userID) {
                return getGrayConfig(appID)
            }
        case "percent":
            if hash(userID) % 100 < rule.Percent {
                return getGrayConfig(appID)
            }
        }
    }
    
    // 3. 返回正式配置
    return getConfig(appID)
}
```

---

## 五、数据模型

```sql
-- 应用表
CREATE TABLE apps (
    id BIGINT PRIMARY KEY,
    app_id VARCHAR(64) UNIQUE,
    name VARCHAR(100),
    created_at TIMESTAMP
);

-- 配置表
CREATE TABLE configs (
    id BIGINT PRIMARY KEY,
    app_id VARCHAR(64),
    env VARCHAR(20),        -- dev/test/prod
    key VARCHAR(200),
    value TEXT,
    version BIGINT,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    UNIQUE KEY uk_app_env_key (app_id, env, key)
);

-- 配置历史表
CREATE TABLE config_history (
    id BIGINT PRIMARY KEY,
    config_id BIGINT,
    value TEXT,
    version BIGINT,
    operator VARCHAR(50),
    created_at TIMESTAMP
);

-- 灰度规则表
CREATE TABLE gray_rules (
    id BIGINT PRIMARY KEY,
    app_id VARCHAR(64),
    rule_type VARCHAR(20),
    rule_value TEXT,
    gray_config TEXT,
    enabled TINYINT,
    created_at TIMESTAMP
);
```

---

## 六、面试追问

| 问题 | 回答 |
|------|------|
| 为什么用长轮询不用 WebSocket？ | 长轮询更简单，无需维护长连接，兼容性好 |
| 配置中心挂了怎么办？ | 客户端本地缓存兜底 |
| 如何保证配置一致性？ | 版本号机制，客户端对比版本 |
| 敏感配置如何处理？ | 加密存储，客户端解密 |
