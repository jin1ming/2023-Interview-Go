# 系统设计与算法面试题解答

## 1. 生产者消费者模型 (多线程/协程往复循环)
**题目要求**：1个生产者生产1-100，n个消费者消费，往复循环。注意生产者和消费者不能同时执行（串行化）。

**思路**：
由于要求“不能同时执行”，这实际上是一个同步交替的过程。
可以使用两个 `Channel` 或者 `Cond` 来控制流程。这里使用 `Channel` 更符合 Go 的风格。
- `produceChan`: 通知生产者开始生产
- `consumeChan`: 通知消费者开始消费

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	// 缓冲区设为0，保证严格同步
	produceChan := make(chan struct{})
	consumeChan := make(chan int)
	var wg sync.WaitGroup
	
	numConsumers := 3 // n个消费者

	// 1. 启动生产者
	wg.Add(1)
	go func() {
		defer wg.Done()
		for round := 1; round <= 3; round++ { // 模拟往复循环3轮
			fmt.Printf("--- 第 %d 轮开始 ---\n", round)
			
			// 生产 1-100
			for i := 1; i <= 100; i++ {
				// 等待生产信号（如果是第一轮第一个数，或者消费者消费完了上一个）
				if i > 1 || round > 1 {
					<-produceChan 
				}
				fmt.Printf("[Producer] %d\n", i)
				// 发送给消费者
				consumeChan <- i
			}
		}
		close(consumeChan) // 生产结束
	}()

	// 2. 启动 n 个消费者
	for i := 0; i < numConsumers; i++ {
		wg.Add(1)
		id := i
		go func(consumerID int) {
			defer wg.Done()
			for num := range consumeChan {
				fmt.Printf("    [Consumer %d] 吃了 %d\n", consumerID, num)
				time.Sleep(time.Millisecond * 10) // 模拟耗时
				
				// 消费完通知生产者继续
				// 注意：这里需要非阻塞或者确保生产者在等，否则死锁
				// 简单模型下，直接发回信号
				select {
				case produceChan <- struct{}{}:
				default:
					// 如果channel已关闭或某些边缘情况
				}
			}
		}(id)
	}
	
	// 初始启动信号（可选，取决于逻辑，上面代码 i=1 时直接发了 consumeChan，所以不需要初始信号）
	// 其实上面代码有一点问题：消费者消费完后通知生产者，但生产者在等待吗？
	// 生产者逻辑调整：生产 -> 发送数据(阻塞直到被收走) -> 等待下一次生产信号
	
	wg.Wait()
}
```

> **修正与优化**：上面的代码为了满足“不能同时执行”，逻辑必须是：P运行 -> P停 -> C运行 -> C停 -> P运行...
> 这通常意味着不需要 buffer channel，且逻辑必须严格卡死。

---

## 2. 可指定大小的协程池 (带结果获取 + 优雅退出)

**核心设计**：
- `Task` 结构体：包含执行函数和结果回传的 Channel。
- `Dispatcher`：管理 worker 队列。
- `Result`：通过 Future 模式获取。
- `WaitGroup`：用于优雅退出。

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// 任务定义
type Task func() interface{}

// 任务包装，包含结果通道
type Job struct {
	Task Task
	Res  chan interface{}
}

type Pool struct {
	jobs    chan Job
	wg      sync.WaitGroup
	quit    chan struct{}
	workers int
}

func NewPool(size int) *Pool {
	p := &Pool{
		jobs:    make(chan Job, 100),
		quit:    make(chan struct{}),
		workers: size,
	}
	// 启动 workers
	for i := 0; i < size; i++ {
		p.wg.Add(1)
		go p.worker(i)
	}
	return p
}

func (p *Pool) worker(id int) {
	defer p.wg.Done()
	for {
		select {
		case job, ok := <-p.jobs:
			if !ok {
				return
			}
			// 执行任务
			res := job.Task()
			// 返回结果
			job.Res <- res
			close(job.Res)
		case <-p.quit:
			// 收到退出信号，但为了"等所有任务结束"，
			// 这里的逻辑通常是：关闭 jobs channel，让 worker 把剩下的消费完自然退出
			return 
		}
	}
}

// 优雅退出：不再接受新任务，等待旧任务完成
func (p *Pool) Stop() {
	close(p.jobs) // 关闭任务通道，worker读完后会退出
	p.wg.Wait()   // 等待所有 worker 结束
}

// 提交任务，返回一个能获取结果的通道（Future模式）
func (p *Pool) Submit(t Task) <-chan interface{} {
	resChan := make(chan interface{}, 1)
	p.jobs <- Job{Task: t, Res: resChan}
	return resChan
}

func main() {
	p := NewPool(3)

	// 提交任务
	future1 := p.Submit(func() interface{} {
		time.Sleep(time.Second)
		return "Result 1"
	})
	
	future2 := p.Submit(func() interface{} {
		return 100 + 200
	})

	// 获取结果
	fmt.Println("Task 1:", <-future1)
	fmt.Println("Task 2:", <-future2)

	p.Stop()
	fmt.Println("Pool stopped gracefully")
}
```

---

## 3. 倒排索引 (Inverted Index) 查找算法

**场景**：KV库存储 `Topic -> Content`。用户输入一句话，查找相关资料。
**实现方案**：利用 PostgreSQL 内置的 **GIN (Generalized Inverted Index)** 索引和全文检索功能。

PostgreSQL 的倒排索引原理是：将文档拆分为 Token（词），建立 `Token -> List<RowID>` 的映射关系。

### 1. 表结构与索引设计

```sql
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    content TEXT,
    -- tsvector 专门用于存储分词后的向量
    search_vector tsvector
);

-- 核心：创建 GIN 倒排索引
-- GIN 索引存储了 (key -> posting list) 结构，查找速度极快
CREATE INDEX idx_search_vector ON documents USING GIN(search_vector);
```

### 2. 写入数据 (构建索引)

PostgreSQL 使用 `to_tsvector` 函数进行分词、去停用词、词干提取。

```sql
-- 假设已安装中文分词插件 (如 zhparser 或 pg_jieba)，配置名为 'chinese'
-- 也可以使用默认的 'simple' (按空格分词)

INSERT INTO documents (content, search_vector)
VALUES (
    '我想看关于手机的电影', 
    to_tsvector('chinese', '我想看关于手机的电影')
);

-- 自动更新：通常使用 Trigger 在 content 变更时自动更新 search_vector
```

### 3. 查询 (Search)

使用 `@@` 操作符配合 `to_tsquery` 进行倒排索引查找。

```sql
-- 查询同时包含 "手机" AND "电影" 的文档
SELECT id, content 
FROM documents 
WHERE search_vector @@ to_tsquery('chinese', '手机 & 电影');

-- 查询 "手机" OR "电脑"
SELECT * FROM documents 
WHERE search_vector @@ to_tsquery('chinese', '手机 | 电脑');
```

### 4. 性能分析

```sql
EXPLAIN ANALYZE 
SELECT * FROM documents 
WHERE search_vector @@ to_tsquery('chinese', '手机 & 电影');
```
**输出预期**：
`Bitmap Heap Scan on documents ...`
`-> Bitmap Index Scan on idx_search_vector ...`

**解析**：
1.  **Bitmap Index Scan**：PG 去 GIN 索引中直接查找 "手机" 和 "电影" 对应的 RowID 位图，并进行位图 AND 运算。
2.  **Bitmap Heap Scan**：根据计算出的 RowID 直接去堆表中取数据，避免全表扫描。

> **优势**：相比于 `LIKE '%手机%'` 的全表扫描，GIN 倒排索引将复杂度降低到了对数级别，适合海量文本搜索。

---

## 4. 螺旋遍历二维数组 (LCR 146)

**Go 代码实现**：
```go
func spiralArray(array [][]int) []int {
    if len(array) == 0 { return nil }
    l, r, t, b := 0, len(array[0])-1, 0, len(array)-1
    res := make([]int, 0, (r+1)*(b+1))
    
    for {
        // Left -> Right
        for i := l; i <= r; i++ { res = append(res, array[t][i]) }
        t++; if t > b { break }
        
        // Top -> Bottom
        for i := t; i <= b; i++ { res = append(res, array[i][r]) }
        r--; if l > r { break }
        
        // Right -> Left
        for i := r; i >= l; i-- { res = append(res, array[b][i]) }
        b--; if t > b { break }
        
        // Bottom -> Top
        for i := b; i >= t; i-- { res = append(res, array[i][l]) }
        l++; if l > r { break }
    }
    return res
}
```

---

## 5. 产品方案：根据用户特征发数据到手机

**方案设计**：
这是一个典型的 **用户画像 + 推荐系统/规则引擎 + 推送系统**。

1.  **数据收集 (Data Collection)**：
    -   埋点数据、业务数据、外部数据。
2.  **用户画像 (User Profile)**：
    -   给用户打标签（Tags）：`性别:男`, `爱好:科技`, `活跃度:高`。
    -   存储在 DMP (Data Management Platform) 或画像库 (如 HBase/ElasticSearch)。
3.  **规则/算法匹配 (Matching)**：
    -   **运营规则**：后台圈选“所有喜欢科技的男性”。
    -   **算法推荐**：协同过滤、CTR预估，计算用户最可能感兴趣的内容。
4.  **触达 (Delivery)**：
    -   通过 Push通道（APNs, FCM, 个推等）发送。

---

## 6. 系统设计：千万级用户准时准确推送

**架构师视角**：
核心挑战是 **海量并发、高可用、时效性、送达率**。

1.  **长连接网关 (Comet/Gateway)**：
    -   维护千万级 WebSocket/TCP 长连接。
    -   Go 语言非常适合（Goroutine开销小），单机可抗数十万连接。
    -   分布式部署，使用 Hash 环做负载均衡，确保用户重连能找到节点。
2.  **消息队列 (削峰填谷)**：
    -   业务系统 -> Kafka/RocketMQ -> 推送服务。
    -   避免高峰期打垮推送服务。
3.  **分级推送策略**：
    -   **准时**：优先级队列。重要通知（如支付成功）走高优通道，营销广告走低优通道。
    -   **批量聚合**：将多条消息合并发送，减少网络 IO。
4.  **厂商通道集成**：
    -   APP 存活时：走自建长连接。
    -   APP 离线时：必须走厂商通道（小米、华为、FCM、APNs），否则无法送达。
5.  **准确性 (ACK机制)**：
    -   服务端发消息 -> 客户端收到 -> 回复 ACK。
    -   超时未收到 ACK -> 重试机制。
6.  **离线消息存储**：
    -   Redis/HBase 存储离线期间的消息，上线后拉取。

---

## 7. 存储选型

| 场景 | 选型建议 | 原因 |
| :--- | :--- | :--- |
| **关系型事务 (订单/支付)** | MySQL / PostgreSQL | ACID事务支持，生态成熟，强一致性 |
| **海量日志/埋点** | ClickHouse / Elasticsearch | OLAP分析能力强，写入吞吐极高 |
| **高速缓存/计数器** | Redis | 内存读写，单线程高性能，数据结构丰富 |
| **文档型/灵活Schema** | MongoDB | 适合爬虫数据、商品详情、开发迭代快 |
| **海量KV/画像/历史单** | HBase / Cassandra / TiKV | 宽表存储，无限水平扩展 |
| **时序数据 (监控)** | Prometheus / InfluxDB | 针对时间序列压缩优化 |
| **对象存储 (图片/视频)** | S3 / MinIO | 廉价，无限容量，CDN加速 |

---

## 8. 三个 Goroutine 交替打印 (0-30)

**题目要求**：Go1, Go2, Go3 依次执行，向 Map 追加 0-30。
**核心**：控制执行顺序 `Go1 -> Go2 -> Go3 -> Go1 ...`

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var mu sync.Mutex
	data := make(map[int]int)
	target := 30
	
	// 当前该谁执行？ 0:Go1, 1:Go2, 2:Go3
	currentGoroutine := 0 
	currentNum := 0
	
	var wg sync.WaitGroup
	wg.Add(3)

	for i := 0; i < 3; i++ {
		go func(id int) {
			defer wg.Done()
			for {
				mu.Lock()
				
				if currentNum > target {
					mu.Unlock()
					return
				}
				
				// 检查是否轮到自己
				if currentGoroutine != id {
					mu.Unlock()
					continue // 自旋等待，或者使用Cond优化以避免CPU空转
				}
				
				// 执行逻辑
				fmt.Printf("go%d: %d\n", id+1, currentNum)
				data[currentNum] = currentNum
				currentNum++
				
				// 移交控制权给下一个
				currentGoroutine = (currentGoroutine + 1) % 3
				
				mu.Unlock()
			}
		}(i)
	}

	wg.Wait()
	fmt.Println("Final Map:", data)
}
```
> **优化提示**：上面的代码使用了 `mu.Unlock() + continue` 进行忙轮询（自旋），虽然逻辑正确但 CPU 占用高。更好的做法是使用 3 个 Channel 组成环形通知链，或者使用 `sync.Cond`。

**Channel 环形版 (更优)**：
```go
func main() {
    ch1 := make(chan struct{}, 1)
    ch2 := make(chan struct{}, 1)
    ch3 := make(chan struct{}, 1)
    
    ch1 <- struct{}{} // 启动信号
    
    // ... 逻辑略，ch1激发go1, go1做完发ch2 ...
}
```
