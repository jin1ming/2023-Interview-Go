# 搜索引擎设计

## 一、核心组件

| 组件 | 说明 |
|------|------|
| 爬虫/数据采集 | 获取原始数据 |
| 分词器 | 中文分词、英文词干提取 |
| 倒排索引 | 核心数据结构 |
| 相关性排序 | TF-IDF、BM25 |
| 查询解析 | 理解用户意图 |

---

## 二、倒排索引

### 正排索引 vs 倒排索引

```
正排索引（文档 → 词）：
  doc1 → ["搜索", "引擎", "设计"]
  doc2 → ["分布式", "搜索", "系统"]

倒排索引（词 → 文档）：
  "搜索" → [doc1, doc2]
  "引擎" → [doc1]
  "分布式" → [doc2]
```

### 倒排索引结构

```go
type PostingList struct {
    DocID     int64
    Frequency int      // 词频
    Positions []int    // 位置信息（用于短语查询）
}

type InvertedIndex struct {
    Term         string
    DocFrequency int            // 包含该词的文档数
    Postings     []PostingList  // 倒排列表
}

// 示例
// "搜索" → {DocFreq: 2, Postings: [{DocID:1, Freq:3, Pos:[0,5,10]}, {DocID:2, Freq:1, Pos:[2]}]}
```

### 构建倒排索引

```go
func BuildIndex(docs []Document) map[string]*InvertedIndex {
    index := make(map[string]*InvertedIndex)
    
    for _, doc := range docs {
        // 1. 分词
        tokens := tokenize(doc.Content)
        
        // 2. 统计词频和位置
        termPositions := make(map[string][]int)
        for pos, token := range tokens {
            termPositions[token] = append(termPositions[token], pos)
        }
        
        // 3. 更新倒排索引
        for term, positions := range termPositions {
            if index[term] == nil {
                index[term] = &InvertedIndex{Term: term}
            }
            index[term].DocFrequency++
            index[term].Postings = append(index[term].Postings, PostingList{
                DocID:     doc.ID,
                Frequency: len(positions),
                Positions: positions,
            })
        }
    }
    
    return index
}
```

---

## 三、分词

### 中文分词方法

| 方法 | 说明 | 示例 |
|------|------|------|
| 正向最大匹配 | 从左到右，优先匹配最长词 | "中华人民共和国" → "中华人民共和国" |
| 逆向最大匹配 | 从右到左匹配 | 效果通常更好 |
| 双向匹配 | 两种都做，取歧义少的 | |
| 统计分词 | HMM、CRF 模型 | jieba 分词 |

### jieba 分词示例

```go
import "github.com/yanyiwu/gojieba"

func Tokenize(text string) []string {
    jieba := gojieba.NewJieba()
    defer jieba.Free()
    
    // 精确模式
    words := jieba.Cut(text, true)
    
    // 过滤停用词
    result := make([]string, 0)
    for _, word := range words {
        if !isStopWord(word) {
            result = append(result, word)
        }
    }
    
    return result
}
```

---

## 四、相关性排序

### TF-IDF

```
TF (词频) = 词在文档中出现次数 / 文档总词数
IDF (逆文档频率) = log(总文档数 / 包含该词的文档数)
TF-IDF = TF × IDF

词频高 + 文档频率低 = 重要性高
```

```go
func TFIDF(term string, doc *Document, index *InvertedIndex, totalDocs int) float64 {
    // TF
    tf := float64(doc.TermFreq[term]) / float64(doc.TotalTerms)
    
    // IDF
    docFreq := index.DocFrequency
    idf := math.Log(float64(totalDocs) / float64(docFreq+1))
    
    return tf * idf
}
```

### BM25（更优）

```go
func BM25(term string, doc *Document, avgDocLen float64, totalDocs int, docFreq int) float64 {
    k1 := 1.2
    b := 0.75
    
    tf := float64(doc.TermFreq[term])
    docLen := float64(doc.TotalTerms)
    
    // IDF 部分
    idf := math.Log((float64(totalDocs)-float64(docFreq)+0.5) / (float64(docFreq)+0.5) + 1)
    
    // TF 部分（带长度归一化）
    tfNorm := (tf * (k1 + 1)) / (tf + k1*(1-b+b*docLen/avgDocLen))
    
    return idf * tfNorm
}
```

---

## 五、查询处理

### 布尔查询

```go
func BooleanQuery(query string, index map[string]*InvertedIndex) []int64 {
    // 解析查询：搜索 AND 引擎
    terms := parseQuery(query)
    
    var result []int64
    for i, term := range terms {
        docs := getDocIDs(index[term])
        if i == 0 {
            result = docs
        } else {
            result = intersect(result, docs)  // AND 操作
        }
    }
    
    return result
}

// 倒排列表求交集（归并）
func intersect(a, b []int64) []int64 {
    result := make([]int64, 0)
    i, j := 0, 0
    for i < len(a) && j < len(b) {
        if a[i] == b[j] {
            result = append(result, a[i])
            i++
            j++
        } else if a[i] < b[j] {
            i++
        } else {
            j++
        }
    }
    return result
}
```

### 短语查询

```go
// "搜索引擎" 必须连续出现
func PhraseQuery(phrase string, index map[string]*InvertedIndex) []int64 {
    terms := tokenize(phrase)
    
    // 1. 先找包含所有词的文档
    docs := BooleanQuery(strings.Join(terms, " AND "), index)
    
    // 2. 检查位置是否连续
    result := make([]int64, 0)
    for _, docID := range docs {
        if checkPositions(docID, terms, index) {
            result = append(result, docID)
        }
    }
    
    return result
}

func checkPositions(docID int64, terms []string, index map[string]*InvertedIndex) bool {
    // 获取每个词在该文档中的位置
    positions := make([][]int, len(terms))
    for i, term := range terms {
        for _, posting := range index[term].Postings {
            if posting.DocID == docID {
                positions[i] = posting.Positions
                break
            }
        }
    }
    
    // 检查是否存在连续位置
    for _, pos := range positions[0] {
        match := true
        for i := 1; i < len(terms); i++ {
            if !contains(positions[i], pos+i) {
                match = false
                break
            }
        }
        if match {
            return true
        }
    }
    
    return false
}
```

---

## 六、分布式架构

```
┌─────────────────────────────────────────────────────────────┐
│                      查询协调节点                             │
│              （解析查询、合并结果、排序）                        │
└─────────────────────────────┬───────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────▼───────┐     ┌───────▼───────┐     ┌───────▼───────┐
│   分片1        │     │   分片2        │     │   分片3        │
│  (doc 0-1M)   │     │  (doc 1M-2M)  │     │  (doc 2M-3M)  │
└───────────────┘     └───────────────┘     └───────────────┘

分片策略：
  - 按文档ID范围分片
  - 按哈希分片
  
查询流程：
  1. 协调节点解析查询
  2. 并行查询所有分片
  3. 合并结果，全局排序
  4. 返回 Top N
```

---

## 七、面试追问

| 问题 | 回答 |
|------|------|
| 倒排索引是什么？ | 词 → 文档列表的映射，支持快速全文检索 |
| TF-IDF 和 BM25 区别？ | BM25 考虑文档长度归一化，效果更好 |
| 如何处理中文分词？ | jieba 等分词器，基于词典+统计模型 |
| 如何处理同义词？ | 查询扩展，或建索引时归一化 |
| ES 如何分片？ | 按文档ID哈希，每个分片独立倒排索引 |
