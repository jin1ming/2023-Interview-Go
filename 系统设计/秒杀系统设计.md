# 秒杀系统设计

## 一、核心挑战

| 挑战 | 说明 |
|------|------|
| 瞬时高并发 | 百万级 QPS 涌入 |
| 超卖问题 | 库存扣减必须准确 |
| 恶意请求 | 刷子、脚本、黄牛 |
| 系统雪崩 | 下游服务被打垮 |

---

## 二、整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                        用户请求                              │
└─────────────────────────────┬───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                      CDN + 静态页面                          │
│                   （拦截 90% 静态请求）                        │
└─────────────────────────────┬───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                     Nginx 限流层                             │
│              （IP限流、令牌桶、黑名单）                         │
└─────────────────────────────┬───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                      网关层                                  │
│           （用户鉴权、风控校验、请求去重）                       │
└─────────────────────────────┬───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                     秒杀服务                                 │
│              （Redis预扣库存、生成订单）                        │
└─────────────────────────────┬───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                      Kafka                                   │
│                  （异步创建订单）                              │
└─────────────────────────────┬───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                    订单服务 + MySQL                          │
│                （持久化、支付、库存同步）                        │
└─────────────────────────────────────────────────────────────┘
```

---

## 三、核心设计

### 1. 多级限流

```
第一层：CDN + 前端
  - 按钮置灰、倒计时
  - 答题验证码（人机校验）

第二层：Nginx
  - IP 限流：limit_req_zone
  - 连接数限制

第三层：网关
  - 用户级限流（每用户每秒1次）
  - 黑名单拦截

第四层：服务
  - 令牌桶限流
  - 熔断降级
```

### 2. Redis 预扣库存

```lua
-- Lua 脚本保证原子性
local stock = redis.call('GET', KEYS[1])
if tonumber(stock) <= 0 then
    return -1  -- 库存不足
end
-- 检查是否已购买
if redis.call('SISMEMBER', KEYS[2], ARGV[1]) == 1 then
    return -2  -- 重复购买
end
-- 扣减库存
redis.call('DECR', KEYS[1])
-- 记录已购买用户
redis.call('SADD', KEYS[2], ARGV[1])
return 1  -- 成功
```

```go
func Seckill(userID, itemID int64) error {
    // 1. Redis 预扣库存
    result := redis.Eval(luaScript, 
        []string{"stock:" + itemID, "bought:" + itemID}, 
        userID)
    
    if result == -1 {
        return errors.New("库存不足")
    }
    if result == -2 {
        return errors.New("重复购买")
    }
    
    // 2. 发送 MQ，异步创建订单
    kafka.Send("seckill-order", &OrderMessage{
        UserID: userID,
        ItemID: itemID,
    })
    
    return nil
}
```

### 3. 异步下单

```go
// 消费者：创建订单
func ConsumeOrder(msg *OrderMessage) {
    // 1. 创建订单（MySQL）
    order := &Order{
        UserID: msg.UserID,
        ItemID: msg.ItemID,
        Status: "待支付",
    }
    db.Create(order)
    
    // 2. 扣减数据库库存
    db.Exec("UPDATE items SET stock = stock - 1 WHERE id = ? AND stock > 0", msg.ItemID)
    
    // 3. 设置订单超时（15分钟未支付取消）
    redis.Set("order:timeout:"+order.ID, order.ID, 15*time.Minute)
}
```

### 4. 库存一致性

```
预热阶段：
  DB 库存 100 → Redis SET stock:item1 100

秒杀阶段：
  Redis 扣减（快）→ MQ → DB 扣减（最终一致）

兜底校验：
  DB 扣减时再次检查 stock > 0
```

### 5. 进阶优化

#### 5.1 库存分片（解决热 Key）

```
问题：单 Redis 节点扛不住 10w+ QPS 的热点商品扣减。
方案：将库存拆分为 N 份，分散到不同 Key（不同分片）。

库存 1000 → 10 个 Key，每个 100：
  stock:item1:0 = 100
  ...
  stock:item1:9 = 100

扣减逻辑：
  随机/Hash 选择一个分片扣减。
  如果该分片库存不足，自动尝试下一个分片（或直接返回失败）。
```

#### 5.2 本地消息表（解决 MQ 发送失败）

```go
// Redis 扣减成功后，不直接发 MQ，而是写本地 DB
func Seckill(userID, itemID int64) {
    // 1. Redis 预扣
    if !redis.Decr("stock:"+itemID) {
        return "已售罄"
    }

    // 2. 开启事务
    tx := db.Begin()
    
    // 3. 创建订单
    order := createOrder(userID, itemID)
    tx.Create(order)
    
    // 4. 写入本地消息表（Status=0 未发送）
    msg := &LocalMessage{
        Topic: "seckill-order",
        Body:  json.Marshal(order),
        Status: 0,
    }
    tx.Create(msg)
    
    tx.Commit() // 事务提交，业务完成
    
    // 5. 异步发送 MQ
    go sendMQ(msg)
}

// 定时任务扫描未发送的消息补发
```

---

## 四、防刷策略

| 策略 | 实现 |
|------|------|
| 验证码 | 图形/滑块验证，防脚本 |
| 限购 | 每用户限购1件，Redis Set 记录 |
| IP限流 | 同IP每秒最多N次请求 |
| 设备指纹 | 识别模拟器、多开 |
| 黑名单 | 风控系统实时拦截 |
| 隐藏接口 | 秒杀开始前不暴露真实URL |

---

## 五、热点问题处理

### 单商品热点

```go
// 本地缓存 + Redis 多副本
func GetStock(itemID int64) int {
    // 1. 先查本地缓存
    if stock, ok := localCache.Get(itemID); ok {
        return stock
    }
    // 2. 随机读 Redis 从节点
    stock := redis.SlaveGet("stock:" + itemID)
    localCache.Set(itemID, stock, 1*time.Second)
    return stock
}
```

### 库存分片

```
总库存 1000 → 分成 10 个 key
  stock:item1:0 = 100
  stock:item1:1 = 100
  ...
  stock:item1:9 = 100

请求按 userID % 10 路由到不同分片
```

---

## 六、降级方案

| 场景 | 降级策略 |
|------|----------|
| Redis 不可用 | 直接返回"系统繁忙" |
| Kafka 积压 | 丢弃非核心消息 |
| DB 压力大 | 关闭非核心查询 |
| 全面故障 | 静态页面"已售罄" |

---

## 七、面试追问

| 问题 | 回答 |
|------|------|
| 如何防止超卖？ | Redis Lua 原子扣减 + DB 乐观锁兜底 |
| 如何保证一人一单？ | Redis Set 记录已购用户 |
| 订单超时如何处理？ | 延迟队列/定时任务扫描，回滚库存 |
| 如何应对热点商品？ | 本地缓存 + 库存分片 + Redis 多副本 |
| MQ 消息丢失怎么办？ | acks=all + 定时对账补偿 |
