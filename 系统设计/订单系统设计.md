# 订单系统设计

## 一、核心功能

| 功能 | 说明 |
|------|------|
| 创建订单 | 下单、库存扣减、价格计算 |
| 订单状态流转 | 待支付→已支付→已发货→已完成 |
| 超时取消 | 未支付订单自动取消 |
| 退款 | 退款申请、审核、退款 |

---

## 二、订单状态机

```
┌─────────┐    支付成功    ┌─────────┐    发货    ┌─────────┐    确认收货   ┌─────────┐
│  待支付  │ ───────────→ │  已支付  │ ────────→ │  已发货  │ ───────────→ │  已完成  │
└─────────┘               └─────────┘            └─────────┘              └─────────┘
     │                         │                      │                        │
     │ 超时/取消               │ 申请退款             │ 申请退款               │ 申请售后
     ▼                         ▼                      ▼                        ▼
┌─────────┐               ┌─────────┐            ┌─────────┐              ┌─────────┐
│  已取消  │               │  退款中  │            │  退款中  │              │  售后中  │
└─────────┘               └─────────┘            └─────────┘              └─────────┘
                               │                      │
                               │ 退款完成             │ 退款完成
                               ▼                      ▼
                          ┌─────────┐            ┌─────────┐
                          │  已退款  │            │  已退款  │
                          └─────────┘            └─────────┘
```

### 状态机实现

```go
type OrderStatus int

const (
    StatusPending   OrderStatus = 1  // 待支付
    StatusPaid      OrderStatus = 2  // 已支付
    StatusShipped   OrderStatus = 3  // 已发货
    StatusCompleted OrderStatus = 4  // 已完成
    StatusCancelled OrderStatus = 5  // 已取消
    StatusRefunding OrderStatus = 6  // 退款中
    StatusRefunded  OrderStatus = 7  // 已退款
)

// 状态转换规则
var transitions = map[OrderStatus][]OrderStatus{
    StatusPending:   {StatusPaid, StatusCancelled},
    StatusPaid:      {StatusShipped, StatusRefunding},
    StatusShipped:   {StatusCompleted, StatusRefunding},
    StatusCompleted: {StatusRefunding},
    StatusRefunding: {StatusRefunded},
}

func (o *Order) CanTransitionTo(newStatus OrderStatus) bool {
    allowedStatuses, ok := transitions[o.Status]
    if !ok {
        return false
    }
    for _, s := range allowedStatuses {
        if s == newStatus {
            return true
        }
    }
    return false
}

func (o *Order) TransitionTo(newStatus OrderStatus) error {
    if !o.CanTransitionTo(newStatus) {
        return fmt.Errorf("invalid transition from %d to %d", o.Status, newStatus)
    }
    o.Status = newStatus
    o.UpdatedAt = time.Now()
    return db.Save(o).Error
}
```

---

## 三、创建订单流程

```go
func CreateOrder(userID int64, items []OrderItem) (*Order, error) {
    // 1. 参数校验
    if len(items) == 0 {
        return nil, errors.New("订单商品不能为空")
    }
    
    // 2. 获取商品信息、计算价格
    var totalAmount int64
    for i, item := range items {
        product := getProduct(item.ProductID)
        items[i].Price = product.Price
        items[i].Amount = product.Price * int64(item.Quantity)
        totalAmount += items[i].Amount
    }
    
    // 3. 开启事务
    tx := db.Begin()
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()
    
    // 4. 扣减库存（乐观锁）
    for _, item := range items {
        result := tx.Model(&Product{}).
            Where("id = ? AND stock >= ?", item.ProductID, item.Quantity).
            Update("stock", gorm.Expr("stock - ?", item.Quantity))
        if result.RowsAffected == 0 {
            tx.Rollback()
            return nil, errors.New("库存不足")
        }
    }
    
    // 5. 创建订单
    order := &Order{
        ID:          snowflake.NextID(),
        UserID:      userID,
        TotalAmount: totalAmount,
        Status:      StatusPending,
        CreatedAt:   time.Now(),
        ExpireAt:    time.Now().Add(30 * time.Minute),
    }
    tx.Create(order)
    
    // 6. 创建订单项
    for _, item := range items {
        item.OrderID = order.ID
        tx.Create(&item)
    }
    
    // 7. 提交事务
    if err := tx.Commit().Error; err != nil {
        return nil, err
    }
    
    // 8. 发送延迟消息（超时取消）
    kafka.SendDelay("order-timeout", &OrderTimeout{OrderID: order.ID}, 30*time.Minute)
    
    return order, nil
}
```

---

## 四、超时取消

### 方案对比

| 方案 | 优点 | 缺点 |
|------|------|------|
| 定时任务扫描 | 简单 | 时效性差，DB压力大 |
| 延迟队列（RocketMQ） | 精确，可靠 | 依赖MQ |
| Redis 过期回调 | 简单 | 不可靠，可能丢失 |
| 时间轮 | 高性能 | 实现复杂 |

### 延迟队列实现

```go
// 发送延迟消息
func SendOrderTimeout(orderID int64, delay time.Duration) {
    // RocketMQ 延迟消息
    msg := &rocketmq.Message{
        Topic: "order-timeout",
        Body:  []byte(strconv.FormatInt(orderID, 10)),
        DelayTimeLevel: getDelayLevel(delay),  // 30分钟对应 level 16
    }
    producer.Send(msg)
}

// 消费超时消息
func ConsumeOrderTimeout(orderID int64) {
    order := getOrder(orderID)
    
    // 检查订单状态
    if order.Status != StatusPending {
        return  // 已支付或已取消，忽略
    }
    
    // 取消订单
    tx := db.Begin()
    
    // 1. 更新订单状态
    order.Status = StatusCancelled
    tx.Save(order)
    
    // 2. 恢复库存
    for _, item := range order.Items {
        tx.Model(&Product{}).
            Where("id = ?", item.ProductID).
            Update("stock", gorm.Expr("stock + ?", item.Quantity))
    }
    
    tx.Commit()
}
```

### Redis ZSet 实现

```go
// 添加到延迟队列
func AddToDelayQueue(orderID int64, expireAt time.Time) {
    redis.ZAdd("order:timeout", redis.Z{
        Score:  float64(expireAt.Unix()),
        Member: orderID,
    })
}

// 定时任务消费（每秒执行）
func ConsumeDelayQueue() {
    now := time.Now().Unix()
    
    // 获取已过期的订单
    orderIDs := redis.ZRangeByScore("order:timeout", redis.ZRangeBy{
        Min: "0",
        Max: strconv.FormatInt(now, 10),
    })
    
    for _, orderID := range orderIDs {
        // 处理超时
        cancelOrder(orderID)
        // 移除
        redis.ZRem("order:timeout", orderID)
    }
}
```

---

## 五、分库分表

### 分片策略

```
订单表：按 user_id % 64 分库
  - 用户查自己订单：单库查询
  - 后台查所有订单：聚合查询或走ES

订单号设计：
  时间戳(8位) + 用户ID后4位 + 序列号(4位)
  如：20231201 + 1234 + 0001 = 2023120112340001
```

### 分库路由

```go
func getOrderDB(userID int64) *gorm.DB {
    dbIndex := userID % 64
    return dbPool[dbIndex]
}

func CreateOrder(userID int64, order *Order) error {
    db := getOrderDB(userID)
    return db.Create(order).Error
}

func GetUserOrders(userID int64) ([]*Order, error) {
    db := getOrderDB(userID)
    var orders []*Order
    db.Where("user_id = ?", userID).Find(&orders)
    return orders, nil
}
```

---

## 六、幂等性设计

```go
// 使用唯一请求ID保证幂等
func CreateOrderIdempotent(requestID string, userID int64, items []OrderItem) (*Order, error) {
    // 1. 检查是否已处理
    if orderID := redis.Get("order:request:" + requestID); orderID != "" {
        return getOrder(orderID), nil
    }
    
    // 2. 加分布式锁
    lock := redis.SetNX("lock:order:"+requestID, "1", 10*time.Second)
    if !lock {
        return nil, errors.New("请勿重复提交")
    }
    defer redis.Del("lock:order:" + requestID)
    
    // 3. 再次检查（双重检查）
    if orderID := redis.Get("order:request:" + requestID); orderID != "" {
        return getOrder(orderID), nil
    }
    
    // 4. 创建订单
    order, err := CreateOrder(userID, items)
    if err != nil {
        return nil, err
    }
    
    // 5. 记录请求ID与订单ID的映射
    redis.Set("order:request:"+requestID, order.ID, 24*time.Hour)
    
    return order, nil
}
```

---

## 七、数据模型

```sql
-- 订单主表
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    order_no VARCHAR(32) UNIQUE NOT NULL,
    user_id BIGINT NOT NULL,
    total_amount BIGINT NOT NULL,  -- 分为单位
    pay_amount BIGINT,
    status TINYINT NOT NULL,
    pay_time TIMESTAMP,
    ship_time TIMESTAMP,
    complete_time TIMESTAMP,
    expire_at TIMESTAMP,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    INDEX idx_user_status (user_id, status),
    INDEX idx_created (created_at)
);

-- 订单项表
CREATE TABLE order_items (
    id BIGINT PRIMARY KEY,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    product_name VARCHAR(200),
    price BIGINT,
    quantity INT,
    amount BIGINT,
    INDEX idx_order (order_id)
);

-- 订单状态变更日志
CREATE TABLE order_status_logs (
    id BIGINT PRIMARY KEY,
    order_id BIGINT NOT NULL,
    from_status TINYINT,
    to_status TINYINT,
    operator VARCHAR(50),
    remark VARCHAR(500),
    created_at TIMESTAMP,
    INDEX idx_order (order_id)
);
```

---

## 八、面试追问

| 问题 | 回答 |
|------|------|
| 如何防止超卖？ | 乐观锁（stock >= quantity）+ 事务 |
| 订单号如何生成？ | Snowflake 或 时间戳+用户ID+序列号 |
| 如何保证幂等？ | 请求ID去重 + 分布式锁 |
| 超时取消用什么方案？ | 延迟队列（RocketMQ）或 Redis ZSet |
| 分库后如何查询？ | 用户维度单库查，全局查询走ES |
| 如何处理分布式事务？ | 本地事务 + 最终一致性（MQ补偿） |
