# 购物车系统设计

## 一、核心功能

| 功能 | 说明 |
|------|------|
| 添加商品 | 加入购物车 |
| 修改数量 | 增减商品数量 |
| 删除商品 | 移除购物车 |
| 选中/取消 | 结算时选择商品 |
| 登录合并 | 游客购物车与用户购物车合并 |
| 库存校验 | 实时校验库存状态 |

---

## 二、存储方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| Cookie | 无服务端存储 | 容量小，不安全 | 简单场景 |
| Session | 简单 | 分布式问题 | 单机 |
| **Redis** | 高性能，支持过期 | 需持久化 | **推荐** |
| MySQL | 持久化可靠 | 性能较低 | 需要持久化 |

### 推荐：Redis Hash

```redis
# 用户购物车
HSET cart:{user_id} {sku_id} {json_data}

# 示例
HSET cart:123 sku_1001 '{"quantity":2,"selected":true,"price":9900}'
HSET cart:123 sku_1002 '{"quantity":1,"selected":true,"price":5900}'

# 获取整个购物车
HGETALL cart:123

# 删除商品
HDEL cart:123 sku_1001

# 设置过期（30天）
EXPIRE cart:123 2592000
```

---

## 三、数据结构

```go
type CartItem struct {
    SkuID      int64  `json:"sku_id"`
    Quantity   int    `json:"quantity"`
    Selected   bool   `json:"selected"`
    Price      int64  `json:"price"`      // 加入时的价格（用于比价）
    AddedAt    int64  `json:"added_at"`
}

type Cart struct {
    UserID int64
    Items  map[int64]*CartItem  // sku_id -> item
}
```

---

## 四、核心接口实现

### 添加商品

```go
func AddToCart(userID, skuID int64, quantity int) error {
    // 1. 校验商品
    sku := getSku(skuID)
    if sku == nil {
        return errors.New("商品不存在")
    }
    if sku.Stock < quantity {
        return errors.New("库存不足")
    }
    
    // 2. 检查购物车是否已有该商品
    key := fmt.Sprintf("cart:%d", userID)
    existing := redis.HGet(key, strconv.FormatInt(skuID, 10))
    
    var item CartItem
    if existing != "" {
        json.Unmarshal([]byte(existing), &item)
        item.Quantity += quantity
    } else {
        item = CartItem{
            SkuID:    skuID,
            Quantity: quantity,
            Selected: true,
            Price:    sku.Price,
            AddedAt:  time.Now().Unix(),
        }
    }
    
    // 3. 限制单品数量
    if item.Quantity > 99 {
        item.Quantity = 99
    }
    
    // 4. 保存
    data, _ := json.Marshal(item)
    redis.HSet(key, strconv.FormatInt(skuID, 10), data)
    redis.Expire(key, 30*24*time.Hour)
    
    return nil
}
```

### 获取购物车

```go
func GetCart(userID int64) (*CartResponse, error) {
    key := fmt.Sprintf("cart:%d", userID)
    
    // 1. 获取购物车数据
    cartData := redis.HGetAll(key)
    if len(cartData) == 0 {
        return &CartResponse{Items: []CartItemVO{}}, nil
    }
    
    // 2. 解析并获取商品最新信息
    var items []CartItemVO
    var skuIDs []int64
    
    for skuIDStr, itemData := range cartData {
        var item CartItem
        json.Unmarshal([]byte(itemData), &item)
        skuIDs = append(skuIDs, item.SkuID)
    }
    
    // 3. 批量获取SKU信息
    skus := batchGetSkus(skuIDs)
    
    // 4. 组装返回数据
    var totalAmount int64
    var selectedCount int
    
    for skuIDStr, itemData := range cartData {
        var item CartItem
        json.Unmarshal([]byte(itemData), &item)
        
        sku := skus[item.SkuID]
        
        vo := CartItemVO{
            SkuID:       item.SkuID,
            ProductName: sku.ProductName,
            SkuName:     sku.SkuName,
            Image:       sku.Image,
            Price:       sku.Price,           // 最新价格
            OrigPrice:   item.Price,          // 加入时价格
            Quantity:    item.Quantity,
            Selected:    item.Selected,
            Stock:       sku.Stock,
            Available:   sku.Status == 1 && sku.Stock > 0,
        }
        
        // 价格变动提示
        if sku.Price != item.Price {
            if sku.Price < item.Price {
                vo.PriceChange = "降价了"
            } else {
                vo.PriceChange = "涨价了"
            }
        }
        
        // 库存不足提示
        if sku.Stock < item.Quantity {
            vo.StockWarning = fmt.Sprintf("库存仅剩%d件", sku.Stock)
        }
        
        items = append(items, vo)
        
        if item.Selected && vo.Available {
            totalAmount += sku.Price * int64(item.Quantity)
            selectedCount += item.Quantity
        }
    }
    
    return &CartResponse{
        Items:         items,
        TotalAmount:   totalAmount,
        SelectedCount: selectedCount,
    }, nil
}
```

### 修改数量

```go
func UpdateQuantity(userID, skuID int64, quantity int) error {
    if quantity <= 0 {
        return RemoveFromCart(userID, skuID)
    }
    if quantity > 99 {
        quantity = 99
    }
    
    key := fmt.Sprintf("cart:%d", userID)
    existing := redis.HGet(key, strconv.FormatInt(skuID, 10))
    if existing == "" {
        return errors.New("商品不在购物车中")
    }
    
    var item CartItem
    json.Unmarshal([]byte(existing), &item)
    item.Quantity = quantity
    
    data, _ := json.Marshal(item)
    redis.HSet(key, strconv.FormatInt(skuID, 10), data)
    
    return nil
}
```

### 选中/取消选中

```go
func UpdateSelected(userID, skuID int64, selected bool) error {
    key := fmt.Sprintf("cart:%d", userID)
    existing := redis.HGet(key, strconv.FormatInt(skuID, 10))
    if existing == "" {
        return errors.New("商品不在购物车中")
    }
    
    var item CartItem
    json.Unmarshal([]byte(existing), &item)
    item.Selected = selected
    
    data, _ := json.Marshal(item)
    redis.HSet(key, strconv.FormatInt(skuID, 10), data)
    
    return nil
}

// 全选/取消全选
func SelectAll(userID int64, selected bool) error {
    key := fmt.Sprintf("cart:%d", userID)
    cartData := redis.HGetAll(key)
    
    for skuIDStr, itemData := range cartData {
        var item CartItem
        json.Unmarshal([]byte(itemData), &item)
        item.Selected = selected
        data, _ := json.Marshal(item)
        redis.HSet(key, skuIDStr, data)
    }
    
    return nil
}
```

---

## 五、登录合并

```go
func MergeCart(guestID, userID int64) error {
    guestKey := fmt.Sprintf("cart:guest:%d", guestID)
    userKey := fmt.Sprintf("cart:%d", userID)
    
    // 1. 获取游客购物车
    guestCart := redis.HGetAll(guestKey)
    if len(guestCart) == 0 {
        return nil
    }
    
    // 2. 获取用户购物车
    userCart := redis.HGetAll(userKey)
    
    // 3. 合并策略：游客购物车覆盖用户购物车（以最新操作为准）
    for skuIDStr, guestItemData := range guestCart {
        var guestItem CartItem
        json.Unmarshal([]byte(guestItemData), &guestItem)
        
        if userItemData, exists := userCart[skuIDStr]; exists {
            // 已存在：数量相加
            var userItem CartItem
            json.Unmarshal([]byte(userItemData), &userItem)
            guestItem.Quantity += userItem.Quantity
            if guestItem.Quantity > 99 {
                guestItem.Quantity = 99
            }
        }
        
        data, _ := json.Marshal(guestItem)
        redis.HSet(userKey, skuIDStr, data)
    }
    
    // 4. 删除游客购物车
    redis.Del(guestKey)
    
    return nil
}
```

---

## 六、购物车限制

```go
const (
    MaxCartItems    = 100  // 最多100种商品
    MaxItemQuantity = 99   // 单品最多99件
)

func AddToCart(userID, skuID int64, quantity int) error {
    key := fmt.Sprintf("cart:%d", userID)
    
    // 检查购物车商品数量
    count := redis.HLen(key)
    if count >= MaxCartItems {
        // 检查是否是新增
        if !redis.HExists(key, strconv.FormatInt(skuID, 10)) {
            return errors.New("购物车已满，最多添加100种商品")
        }
    }
    
    // ... 后续逻辑
}
```

---

## 七、数据持久化（可选）

```sql
-- 购物车表（用于持久化）
CREATE TABLE carts (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    sku_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    selected TINYINT DEFAULT 1,
    price BIGINT,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    UNIQUE KEY uk_user_sku (user_id, sku_id),
    INDEX idx_user (user_id)
);
```

```go
// 定时同步 Redis → MySQL
func SyncCartToDB(userID int64) {
    key := fmt.Sprintf("cart:%d", userID)
    cartData := redis.HGetAll(key)
    
    for _, itemData := range cartData {
        var item CartItem
        json.Unmarshal([]byte(itemData), &item)
        
        db.Clauses(clause.OnConflict{
            Columns:   []clause.Column{{Name: "user_id"}, {Name: "sku_id"}},
            DoUpdates: clause.AssignmentColumns([]string{"quantity", "selected", "updated_at"}),
        }).Create(&CartModel{
            UserID:   userID,
            SkuID:    item.SkuID,
            Quantity: item.Quantity,
            Selected: item.Selected,
        })
    }
}
```

---

## 八、面试追问

| 问题 | 回答 |
|------|------|
| 为什么用 Redis Hash？ | 支持单个商品的增删改，性能高 |
| 游客购物车怎么存？ | 用设备ID或临时Token作为key |
| 如何处理商品下架？ | 查询时过滤，展示"已失效" |
| 价格变动怎么处理？ | 存储加入时价格，展示时对比最新价格 |
| 购物车数据会丢吗？ | Redis 持久化 + 定时同步MySQL |
| 高并发下如何保证一致性？ | Redis 原子操作，必要时加分布式锁 |
