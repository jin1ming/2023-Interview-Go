# 短链系统设计

## 一、需求分析

| 功能 | 说明 |
|------|------|
| 生成短链 | 长URL → 短URL（如 https://t.cn/abc123） |
| 重定向 | 访问短链 → 跳转原URL |
| 统计 | 点击次数、来源分析 |
| 过期 | 可选设置有效期 |

---

## 二、核心问题：如何生成短码？

### 方案对比

| 方案 | 原理 | 优点 | 缺点 |
|------|------|------|------|
| **哈希算法** | MD5/MurmurHash 取前N位 | 简单 | 冲突需处理 |
| **自增ID** | 数据库自增 → 62进制 | 无冲突 | 单点瓶颈 |
| **发号器** | 分布式ID生成 → 62进制 | 高性能 | 实现复杂 |

### 推荐：发号器 + 62进制

```go
// 62进制字符表
const base62 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

// ID 转 62进制短码
func Encode(id int64) string {
    if id == 0 {
        return "0"
    }
    var result []byte
    for id > 0 {
        result = append([]byte{base62[id%62]}, result...)
        id /= 62
    }
    return string(result)
}

// 62进制短码 转 ID
func Decode(code string) int64 {
    var id int64
    for _, c := range code {
        id = id*62 + int64(strings.IndexByte(base62, byte(c)))
    }
    return id
}

// 示例：
// ID 1000000 → 62进制 "4c92"（4位）
// 6位短码可表示：62^6 = 568亿 个URL
```

---

## 三、整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                        客户端                                │
└─────────────────────────────┬───────────────────────────────┘
                              │
┌─────────────────────────────▼───────────────────────────────┐
│                      API Gateway                             │
│                  （限流、鉴权）                                │
└─────────────────────────────┬───────────────────────────────┘
                              │
        ┌─────────────────────┴─────────────────────┐
        │                                           │
┌───────▼───────┐                           ┌───────▼───────┐
│   生成服务     │                           │   重定向服务   │
│  POST /shorten │                           │  GET /{code}  │
└───────┬───────┘                           └───────┬───────┘
        │                                           │
┌───────▼───────────────────────────────────────────▼───────┐
│                        Redis                               │
│                   （短码 → 长URL 缓存）                      │
└───────────────────────────┬───────────────────────────────┘
                            │
┌───────────────────────────▼───────────────────────────────┐
│                        MySQL                               │
│                    （持久化存储）                            │
└───────────────────────────────────────────────────────────┘
```

---

## 四、数据模型

```sql
CREATE TABLE short_urls (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    short_code VARCHAR(10) UNIQUE NOT NULL,
    long_url VARCHAR(2048) NOT NULL,
    user_id BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expired_at TIMESTAMP,
    click_count BIGINT DEFAULT 0,
    INDEX idx_short_code (short_code),
    INDEX idx_long_url (long_url(255))  -- 前缀索引，用于查重
);
```

---

## 五、核心流程

### 生成短链

```go
func CreateShortURL(longURL string) (string, error) {
    // 1. 查重：同一长URL是否已存在
    if code := redis.Get("long2short:" + md5(longURL)); code != "" {
        return code, nil
    }
    
    // 2. 获取分布式ID
    id := snowflake.NextID()
    
    // 3. 转62进制
    shortCode := Encode(id)
    
    // 4. 存储
    db.Create(&ShortURL{
        ID:        id,
        ShortCode: shortCode,
        LongURL:   longURL,
    })
    
    // 5. 缓存
    redis.Set("short:" + shortCode, longURL, 30*24*time.Hour)
    redis.Set("long2short:" + md5(longURL), shortCode, 30*24*time.Hour)
    
    return shortCode, nil
}
```

### 重定向

```go
func Redirect(shortCode string) (string, error) {
    // 1. 查缓存
    if longURL := redis.Get("short:" + shortCode); longURL != "" {
        go incrClickCount(shortCode)  // 异步统计
        return longURL, nil
    }
    
    // 2. 查数据库
    var url ShortURL
    if err := db.Where("short_code = ?", shortCode).First(&url).Error; err != nil {
        return "", errors.New("短链不存在")
    }
    
    // 3. 检查过期
    if url.ExpiredAt != nil && url.ExpiredAt.Before(time.Now()) {
        return "", errors.New("短链已过期")
    }
    
    // 4. 回填缓存
    redis.Set("short:" + shortCode, url.LongURL, 30*24*time.Hour)
    
    return url.LongURL, nil
}
```

---

## 六、关键设计点

### 1. 301 vs 302 重定向

| 状态码 | 含义 | 场景 |
|--------|------|------|
| **301** | 永久重定向，浏览器缓存 | 不需要统计点击 |
| **302** | 临时重定向，每次请求服务器 | 需要统计点击（推荐） |

### 2. 布隆过滤器（防缓存穿透）

```go
func Redirect(shortCode string) (string, error) {
    // 先查布隆过滤器
    if !bloomFilter.Exists(shortCode) {
        return "", errors.New("短链不存在")
    }
    // 再查缓存和DB...
}
```

### 3. 发号器设计

```go
// 方案1：Snowflake
id := snowflake.NextID()  // 64位，支持分布式

// 方案2：号段模式（美团Leaf）
// 每次从DB取一段ID（如1000-1999），本地发放
type IDGenerator struct {
    currentID int64
    maxID     int64
    mu        sync.Mutex
}

func (g *IDGenerator) NextID() int64 {
    g.mu.Lock()
    defer g.mu.Unlock()
    if g.currentID >= g.maxID {
        g.loadSegment()  // 从DB获取新号段
    }
    g.currentID++
    return g.currentID
}
```

### 4. 自定义短码

```go
func CreateCustomShortURL(longURL, customCode string) error {
    // 检查自定义短码是否被占用
    if exists := db.Where("short_code = ?", customCode).First(&ShortURL{}).Error; exists == nil {
        return errors.New("短码已被占用")
    }
    // 创建...
}
```

---

## 七、高可用设计

### 缓存策略

```
热点短链：Redis 缓存，TTL 30天
冷数据：LRU 淘汰，访问时回填
```

### 数据库分库

```
按 short_code 首字符分库（62个分片）
或按 ID 范围分库
```

---

## 八、容量估算

| 指标 | 估算 |
|------|------|
| 日新增短链 | 1亿条 |
| 日访问量 | 10亿次 |
| 读写比 | 10:1 |
| 存储（5年） | 1亿 × 365 × 5 × 1KB ≈ 180TB |
| 短码长度 | 6位（62^6 = 568亿，够用） |

---

## 九、面试追问

| 问题 | 回答 |
|------|------|
| 如何保证短码不重复？ | 发号器生成唯一ID，转62进制 |
| 相同长URL生成相同短链？ | 用长URL的MD5做key查重 |
| 如何处理过期短链？ | 定时任务清理 + 访问时校验 |
| 短码用完了怎么办？ | 6位够用568亿，不够就加位 |
| 如何防止恶意刷？ | 限流 + 验证码 + 黑名单 |

---

## 十、核心技术深度解析

### 1. 为什么选择 62 进制 (Base62)？
- **组成**：`0-9` (10) + `a-z` (26) + `A-Z` (26) = 62 个字符。
- **优势**：
    - **高密度**：相比 10 进制，信息密度更高，短字符串能表示更大的数值。
    - **URL安全**：不含 Base64 中的 `+`、`/`、`=` 等特殊字符，无需转义。
- **转换算法**：
    - **Encode (ID → Code)**：类似 10 进制转 2 进制，不断 `ID % 62` 取余做字符，`ID / 62` 取整。
    - **Decode (Code → ID)**：逆向计算，公式为 $\sum (\text{字符值} \times 62^{\text{位权}})$。
    - **查询优化**：利用 Decode 将短码转回 ID，直接通过数据库 **主键索引 (Long)** 查询，比查询字符串索引 (String) 快且省空间。

### 2. 为什么不用 UUID？
- **太长 (违背初衷)**：UUID (128 bit) 转为 Base62 仍需约 **22 位**字符，而自增 ID 方案仅需 6 位。
- **写入性能差**：UUID 是无序的，导致 MySQL InnoDB 引擎的 B+ 树索引频繁发生 **页分裂 (Page Split)**，大幅降低写入速度。
- **存储浪费**：主键过长会导致所有二级索引膨胀（二级索引叶节点存主键），降低 Buffer Pool 效率。

### 3. 生成策略：Hash vs 发号器
| 特性 | 基于 Hash (MD5) | 基于发号器 (自增 ID) |
| :--- | :--- | :--- |
| **原理** | Hash(长URL) -> 截取 -> 转 Base62 | ID 生成器 -> 转 Base62 |
| **长URL相同** | 生成的短链 **相同** | 生成的短链 **不同** (除非额外查重) |
| **冲突处理** | 需解决 Hash 冲突 (加盐重算) | **天然无冲突** |
| **性能** | 中 (需计算 Hash) | **极高** (仅 ID 转换) |
| **适用场景** | 只有短链生成需求，无 ID 生成器 | **高性能通用方案 (主流)** |

### 4. 发号器深度：号段模式 (Segment Mode)
- **核心思想**：**“批发代替零售”**。应用服务每次从数据库申请一批 ID (如 1000 个)，在内存中自增发放。
- **数据库表设计**：
    ```sql
    UPDATE id_generator SET max_id = max_id + step WHERE biz_tag = 'short_url'
    ```
- **流程**：
    1. 服务启动或号段用尽，更新 DB 申请新号段。
    2. 获取范围 `[max_id, max_id + step)`。
    3. 内存中通过 `AtomicLong` 顺序发号，**无需访问数据库**。
- **双号段缓冲 (Double Buffer)**：
    - 为了解决号段用尽瞬间的数据库访问抖动，在当前号段用到一定比例 (如 20%) 时，异步线程提前申请下一个号段备用。

### 5. 容量规划 (62进制)
| 位数 | 容量 (62^N) | 说明 |
| :--- | :--- | :--- |
| **5位** | ~9.1 亿 | 中型系统瓶颈，大厂容易用完 |
| **6位** | **~568 亿** | **工业界黄金标准**，足够支撑绝大多数业务数十年 |
| **7位** | ~3.5 万亿 | 全球级巨量系统 |
| **8位** | ~218 万亿 | 存储成为瓶颈，而非 ID |

