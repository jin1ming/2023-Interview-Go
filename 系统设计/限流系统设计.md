# 限流系统设计

## 一、限流算法对比

| 算法 | 原理 | 优点 | 缺点 |
|------|------|------|------|
| **固定窗口** | 时间窗口计数 | 简单 | 临界点突刺 |
| **滑动窗口** | 滑动时间窗口 | 平滑 | 内存占用高 |
| **漏桶** | 固定速率流出 | 平滑流量 | 无法应对突发 |
| **令牌桶** | 固定速率生成令牌 | 允许突发 | 实现复杂 |

---

## 二、滑动窗口（Redis ZSet）

```go
func SlidingWindowLimit(key string, limit int, window time.Duration) bool {
    now := time.Now().UnixNano()
    windowStart := now - int64(window)
    
    pipe := redis.Pipeline()
    pipe.ZRemRangeByScore(key, "0", strconv.FormatInt(windowStart, 10))
    pipe.ZCard(key)
    pipe.ZAdd(key, redis.Z{Score: float64(now), Member: now})
    pipe.Expire(key, window)
    
    results, _ := pipe.Exec()
    count := results[1].(*redis.IntCmd).Val()
    
    return count < int64(limit)
}
```

---

## 三、令牌桶（推荐）

```go
// Redis Lua 脚本实现
local key = KEYS[1]
local rate = tonumber(ARGV[1])      -- 每秒生成令牌数
local capacity = tonumber(ARGV[2])  -- 桶容量
local now = tonumber(ARGV[3])
local requested = tonumber(ARGV[4]) -- 请求令牌数

local data = redis.call('HMGET', key, 'tokens', 'last_time')
local tokens = tonumber(data[1]) or capacity
local last_time = tonumber(data[2]) or now

-- 计算新增令牌
local delta = (now - last_time) * rate
tokens = math.min(capacity, tokens + delta)

-- 判断是否有足够令牌
if tokens >= requested then
    tokens = tokens - requested
    redis.call('HMSET', key, 'tokens', tokens, 'last_time', now)
    redis.call('EXPIRE', key, capacity / rate * 2)
    return 1  -- 通过
else
    redis.call('HMSET', key, 'tokens', tokens, 'last_time', now)
    return 0  -- 拒绝
end
```

```go
func TokenBucketLimit(key string, rate, capacity, requested int) bool {
    now := time.Now().Unix()
    result := redis.Eval(tokenBucketScript, []string{key}, rate, capacity, now, requested)
    return result.(int64) == 1
}
```

---

## 四、分布式限流架构

```
┌─────────────────────────────────────────────────────────┐
│                      API Gateway                         │
│                    （全局限流）                           │
└─────────────────────────────┬───────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────▼───────┐     ┌───────▼───────┐     ┌───────▼───────┐
│   服务实例1    │     │   服务实例2    │     │   服务实例3    │
│  （本地限流）   │     │  （本地限流）   │     │  （本地限流）   │
└───────┬───────┘     └───────┬───────┘     └───────┬───────┘
        │                     │                     │
        └─────────────────────┼─────────────────────┘
                              │
                    ┌─────────▼─────────┐
                    │   Redis Cluster   │
                    │   （分布式计数）    │
                    └───────────────────┘
```

---

## 五、多维度限流

```go
// 限流维度
type RateLimitConfig struct {
    // 全局限流
    GlobalQPS int  // 1000
    
    // 用户级限流
    UserQPS int    // 100
    
    // IP级限流
    IPQPS int      // 50
    
    // 接口级限流
    APIQPS map[string]int  // "/api/order": 500
}

func RateLimit(userID, ip, api string) bool {
    // 1. 全局限流
    if !limit("global", config.GlobalQPS) {
        return false
    }
    
    // 2. 用户限流
    if !limit("user:"+userID, config.UserQPS) {
        return false
    }
    
    // 3. IP限流
    if !limit("ip:"+ip, config.IPQPS) {
        return false
    }
    
    // 4. 接口限流
    if qps, ok := config.APIQPS[api]; ok {
        if !limit("api:"+api, qps) {
            return false
        }
    }
    
    return true
}
```

---

## 六、面试追问

| 问题 | 回答 |
|------|------|
| 令牌桶和漏桶区别？ | 令牌桶允许突发，漏桶严格匀速 |
| 分布式限流怎么做？ | Redis 集中计数，Lua 保证原子性 |
| 限流后怎么处理？ | 返回 429 + Retry-After 头 |
| 如何动态调整限流？ | 配置中心下发，热更新 |
