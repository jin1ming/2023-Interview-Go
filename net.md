- 浏览器访问一个网站，都经历了怎样一个流程？

  1、DNS 解析:将域名解析成 IP 地址
  2、TCP 连接：TCP 三次握手
  3、发送 HTTP 请求
  4、服务器处理请求并返回 HTTP 报文
  5、浏览器解析渲染页面
  6、断开连接：TCP 四次挥手

- 什么是HTTP与HTTPS有什么区别？

  1、HTTP的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
  2、HTTP是不安全的，而 HTTPS 是安全的
  3、HTTP标准端口是80 ，而 HTTPS 的标准端口是443
  4、在OSI网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
  5、HTTP无法加密，而HTTPS 对传输的数据进行加密
  6、HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书

- 什么是Http协议无状态协议?怎么解决Http协议无状态协议?

  无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。
  也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。
  可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，
  当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“

- HTTP请求报文与响应报文格式？

  - 请求报文包含： 
    1、请求行：包含请求方法、URI、HTTP版本信息 
    2、请求头部字段
    3、空行
    4、请求内容实体


  - 响应报文包含： 
    1、状态行：包含HTTP版本、状态码、状态码的原因短语 
    2、响应头部字段
    3、空行 
    4、响应内容实体


- HTTP常见的状态码有哪些？

  1XX系列：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。由于 HTTP/1.0 协议中没有定义任何
  1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。

  

  2XX系列：代表请求已成功被服务器接收、理解、并接受。这系列中最常见的有200、201状态码。
  200状态码：表示请求已成功，请求所希望的响应头或数据体将随此响应返回
  201状态码：表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。假如需要的资源
  无法及时建立的话，应当返回 ‘202 Accepted’

  202状态码：服务器已接受请求，但尚未处理

  

  3XX系列：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标
  ）在本次响应的 Location 域中指明。这系列中最常见的有301、302状态码。
  301状态码：被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动
  将请求者转到新位置。

  302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求

  304自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 如果网页自请求者上次请
  求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。

  

  4XX系列：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。
  401状态码：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
  403状态码：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且
  这个请求也不应该被重复提交。

  404状态码：请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。

  

  5xx系列：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬
  件资源无法完成对请求的处理。常见有500、503状态码。
  500状态码：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在
  服务器的程序码出错时出现。
  503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。通常，这个是暂时状态，一段时间会恢复

- 网络的七层结构及其作用？

  - 应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用

  - 表示层（数据）：主要解决用户信息的语法表示问题，如加密解密

  - 会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的

  - 传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等

  - 网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的传输

  - 数据链路层（帧）：将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正

  - 物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等


- TCP/IP协议四层?

​		应用层、传输层、网络层、数据链路层

- TCP协议和UDP协议有什么区别？

- TCP和UDP协议属于传输层协议，主要区别：
  1、TCP是面向连接的，UDP是无连接的;
  2、TCP是可靠的，UDP是不可靠的;
  3、TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式;
  4、TCP是面向字节流的，UDP是面向报文的;
  5、TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信;
  6、TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大;

- TCP协议的三次握手和四次挥手？为什么是三次和四次？

  - 三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)
    
    第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，
    等待Server确认。
    
    第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，
    随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
    
    第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据
    包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状
    态，完成三次握手，随后Client与Server之间可以开始传输数据了。


  - 四次挥手(我要和你断开链接;好的，断吧。我也要和你断开链接;好的，断吧)
    
    第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 
    
    第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)，Server进
    入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。 
    
    第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 
    
    第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进
    入CLOSED状态，完成四次挥手。


​	**三次握手**：目的是为了防止已失效的链接请求报文突然又传送到了服务端，因而产生错误。

​	**四次挥手**：TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据;B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。

- http1.0、http1.1、http2.0有什么区别？

  - http1.0和http1.1区别：
    	1、http1.1默认开启长连接keep-alive，在一个TCP连接(一次完整的tcp握手和挥手)上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。
    	2、http1.0客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。
    	3、http1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。

  - http1.1和http2.0区别:
    1、http2.0在1.1的基础上增加了多路复用，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
    http1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。
    2、http1.1不支持header数据的压缩，http2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
    3、http2.0引入了server push，它允许服务端推送资源给浏览器，免得客户端再次创建连接发送请求到服务器端获取。(例如：客户端向服务器发送一个获取html的请求，
    不需要再次请求去获取html所依赖的css、js，而是在第一次html请求时，服务器端主动的都推送给客户端)

- ProtoBuff协议相比其它有什么好处？

    pb是一种轻便高效的"结构化数据"存储格式，可以用于"结构化数据"的序列化和反序列化。
    		1、跨语言，支持大多数语言开发，代码开源，运行稳定可靠。
    		2、性能好、效率高，占据空间和运行时间相比json和xml小，二进制序列化格式，数据压缩紧凑，占据字节数小。
    		3、支持向后向前兼容，比如向后兼容：A、B两模块，B升级有"statue"属性，可设置为非必填或者缺省，这样A就被兼容了。
    		4、适合数据大、传输速率敏感的场合使用。
    		5、支持数据类型多。
    		6、数据结构化定义灵活，可嵌套定义。
